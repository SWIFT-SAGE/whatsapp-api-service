<!DOCTYPE html>
<html lang="en">
<head>
    <%- include('../partials/head') %>
</head>
<body>
<!-- Dashboard View -->
<div id="dashboard-view" class="view">
    <style>
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border-radius: 8px;
            backdrop-filter: blur(2px);
        }
        
        .loading-content {
            text-align: center;
            padding: 2rem;
        }
        
        .loading-content .spinner-border {
            width: 3rem;
            height: 3rem;
        }
        
        .dashboard-section {
            position: relative;
            min-height: 200px;
        }

        /* Mobile Sidebar Toggle Button */
        .sidebar-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1050;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--whatsapp-green) 0%, var(--whatsapp-green-dark) 100%);
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(37, 211, 102, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(37, 211, 102, 0.5);
        }

        .sidebar-toggle:active {
            transform: scale(0.95);
        }

        /* Sidebar Close Button */
        .sidebar-close {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .sidebar-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        /* Sidebar Overlay */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1040;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Mobile Sidebar Styles */
        @media (max-width: 991.98px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: -100%;
                width: 280px;
                height: 100vh;
                z-index: 1045;
                transition: left 0.3s ease;
                overflow-y: auto;
            }

            .sidebar.active {
                left: 0;
            }

            .sidebar-header {
                position: relative;
                padding-right: 4rem;
            }

            .dashboard-content {
                margin-top: 80px;
            }
        }

        /* Desktop - Hide mobile controls */
        @media (min-width: 992px) {
            .sidebar-toggle,
            .sidebar-close,
            .sidebar-overlay {
                display: none !important;
            }
        }
    </style>
    <div class="dashboard-container">
        <div class="container-fluid">
            <!-- Mobile Toggle Button -->
            <button class="sidebar-toggle d-lg-none" id="sidebarToggle" aria-label="Toggle Sidebar">
                <i class="fas fa-bars"></i>
            </button>

            <div class="row">
                <!-- Sidebar -->
                <div class="col-lg-3 col-xl-2 px-0">
                    <div class="sidebar" id="dashboardSidebar">
                        <div class="sidebar-header">
                            <h5>Dashboard</h5>
                            <button class="sidebar-close d-lg-none" id="sidebarClose" aria-label="Close Sidebar">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <nav class="sidebar-nav">
                            <a href="#" class="nav-link active" data-section="overview">
                                <i class="fas fa-chart-line me-2"></i>Overview
                            </a>
                            <a href="#" class="nav-link" data-section="sessions">
                                <i class="fas fa-mobile-alt me-2"></i>Sessions
                            </a>
                            <a href="#" class="nav-link" data-section="messages">
                                <i class="fas fa-comments me-2"></i>Messages
                            </a>
                            <a href="#" class="nav-link" data-section="templates">
                                <i class="fas fa-file-alt me-2"></i>Templates
                            </a>
                            <a href="#" class="nav-link" data-section="chatbot" id="chatbot-nav">
                                <i class="fas fa-robot me-2"></i>Chatbot
                            </a>
                            <a href="#" class="nav-link" data-section="analytics">
                                <i class="fas fa-chart-pie me-2"></i>Analytics
                            </a>
                            <a href="#" class="nav-link" data-section="billing">
                                <i class="fas fa-credit-card me-2"></i>Billing
                            </a>
                            <a href="#" class="nav-link" data-section="profile">
                                <i class="fas fa-user me-2"></i>Profile
                            </a>
                            <a href="/api-docs" class="nav-link" target="_blank">
                                <i class="fas fa-code me-2"></i>API Docs
                            </a>
                        </nav>
                    </div>
                </div>

                <!-- Sidebar Overlay for Mobile -->
                <div class="sidebar-overlay d-lg-none" id="sidebarOverlay"></div>

                <!-- Main Content -->
                <div class="col-lg-9 col-xl-10">
                    <div class="dashboard-content">
                        <!-- Dynamic Content Container -->
                        <div id="dashboard-content-container">
                            <!-- Content will be loaded dynamically here -->
                        </div>



                    </div>
                </div>

                <!-- Modal cleanup script -->
                <script>
                    // Clean up modal backdrop when QR code modal is closed
                    document.addEventListener('DOMContentLoaded', function() {
                        const qrModal = document.getElementById('qrCodeModal');
                        if (qrModal) {
                            qrModal.addEventListener('hidden.bs.modal', function() {
                                // Remove any lingering backdrop
                                const backdrops = document.querySelectorAll('.modal-backdrop');
                                backdrops.forEach(backdrop => backdrop.remove());
                                
                                // Remove modal-open class from body
                                document.body.classList.remove('modal-open');
                                
                                // Reset body style
                                document.body.style.overflow = '';
                                document.body.style.paddingRight = '';
                                
                            });
                        }
                    });
                </script>

                <!-- Session button group styling -->
                <style>
                    .btn-group .btn {
                        margin-right: 2px;
                    }
                    .btn-group .btn:last-child {
                        margin-right: 0;
                    }
                    .btn-group .btn-sm {
                        font-size: 0.75rem;
                        padding: 0.25rem 0.5rem;
                    }
                    .session-card .btn-group {
                        margin-top: 0.5rem;
                    }
                </style>
            </div>
        </div>
    </div>
</div>

<script>
    // Global API functions - defined before DOMContentLoaded
    window.getApiKey = function getApiKey() {
        // Use comprehensive API key checking (same as loadSessionsData)
        let apiKey = '';
        
        // Check window.currentUser first (updated by dashboard)
        if (window.currentUser && window.currentUser.apiKey) {
            apiKey = window.currentUser.apiKey;
        }
        
        // Also check sessionStorage for the most recent user data
        const storedUser = sessionStorage.getItem('currentUser');
        if (storedUser && !apiKey) {
            try {
                const userObj = JSON.parse(storedUser);
                if (userObj.apiKey && userObj.apiKey !== 'Not generated') {
                    apiKey = userObj.apiKey;
                }
            } catch (e) {
                console.error('Error parsing stored user:', e);
            }
        }
        
        // Fallback to input field if available (on overview page)
        if (!apiKey) {
            const apiKeyInput = document.getElementById('api-key');
            if (apiKeyInput && apiKeyInput.value && apiKeyInput.value !== 'Not generated') {
                apiKey = apiKeyInput.value;
            }
        }
        
        return apiKey;
    }

    function getJwtToken() {
        const token = sessionStorage.getItem('authToken');
        if (!token || token === 'undefined' || token === 'null') {
            return null;
        }
        return token;
    }

    function getApiKeyHeaders() {
        const apiKey = getApiKey();
        if (!apiKey) {
            throw new Error('API key not found. Please generate an API key first.');
        }
        return {
            'Content-Type': 'application/json',
            'x-api-key': apiKey
        };
    }

    function getJwtHeaders() {
        const token = getJwtToken();
        return {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        };
    }

    // Make makeApiCall globally available
    window.makeApiCall = async function makeApiCall(endpoint, options = {}) {
        try {
            // Check if user is logged in first
            const isLoggedIn = sessionStorage.getItem('isLoggedIn') === 'true';
            if (!isLoggedIn) {
                throw new Error('User not logged in');
            }

            // Use JWT authentication for dashboard (cookies are sent automatically)
            // This works with the flexible auth middleware that accepts both JWT and API keys
            const response = await fetch(endpoint, {
                credentials: 'include', // Include cookies for JWT authentication
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                },
                ...options
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                if (response.status === 401) {
                    if (errorData.error === 'Access token required') {
                        throw new Error('Please log in to access this feature.');
                    } else if (errorData.error === 'API key required') {
                        throw new Error('Please generate an API key first.');
                    } else if (errorData.error === 'Invalid API key') {
                        throw new Error('Invalid API key. Please generate a new one.');
                    }
                }
                throw new Error(errorData.message || errorData.error || `HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            if (!error.message.includes('not logged in') &&
                !error.message.includes('log in') &&
                !error.message.includes('API key')) {
                console.error('API call failed:', error);
            }
            throw error;
        }
    }

    // Dashboard functionality
    document.addEventListener('DOMContentLoaded', function () {
        // Only run dashboard initialization if we're on the dashboard page
        if (window.location.pathname !== '/dashboard') {
            console.log('Not on dashboard page, skipping dashboard initialization');
            return;
        }
        
        // Check authentication before initializing dashboard
        function checkAuthentication() {
            const authToken = sessionStorage.getItem('authToken');
            const cookieAuthToken = document.cookie.split('; ').find(row => row.startsWith('authToken='));
            
            // If no token in sessionStorage or cookies, redirect to login
            if (!authToken && !cookieAuthToken) {
                console.warn('No authentication token found, redirecting to login');
                window.location.replace('/login?session=expired');
                return false;
            }
            
            return true;
        }
        
        // Verify authentication on page load
        if (!checkAuthentication()) {
            return; // Stop dashboard initialization if not authenticated
        }
        
        // Re-check authentication periodically (every 30 seconds)
        setInterval(() => {
            if (!checkAuthentication()) {
                console.warn('Session expired, redirecting to login');
            }
        }, 30000);
        
        // Mobile Sidebar Toggle Functionality
        const sidebarToggle = document.getElementById('sidebarToggle');
        const sidebarClose = document.getElementById('sidebarClose');
        const sidebar = document.getElementById('dashboardSidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        
        function openSidebar() {
            sidebar.classList.add('active');
            sidebarOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closeSidebar() {
            sidebar.classList.remove('active');
            sidebarOverlay.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        if (sidebarToggle) {
            sidebarToggle.addEventListener('click', openSidebar);
        }
        
        if (sidebarClose) {
            sidebarClose.addEventListener('click', closeSidebar);
        }
        
        if (sidebarOverlay) {
            sidebarOverlay.addEventListener('click', closeSidebar);
        }
        
        // Close sidebar when clicking on a nav link (mobile only)
        const sidebarNavLinks = document.querySelectorAll('.sidebar-nav .nav-link');
        sidebarNavLinks.forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth < 992) {
                    closeSidebar();
                }
            });
        });
        
        // Global cleanup function for modal backdrops
        window.cleanupModalBackdrops = function cleanupModalBackdrops() {
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
            console.log('Modal backdrops cleaned up manually');
        };
        
        // Utility functions for loading states and errors
        function showLoading(section) {
            const sectionElement = document.getElementById(`dashboard-${section}`);
            if (sectionElement) {
                // Create loading overlay
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = `loading-${section}`;
                loadingOverlay.className = 'loading-overlay';
                loadingOverlay.innerHTML = `
                    <div class="loading-content">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="text-muted">Loading ${section} data...</p>
                    </div>
                `;
                
                // Add loading overlay
                sectionElement.appendChild(loadingOverlay);
            }
        }

        function hideLoading(section) {
            const sectionElement = document.getElementById(`dashboard-${section}`);
            if (sectionElement) {
                const loadingOverlay = document.getElementById(`loading-${section}`);
                if (loadingOverlay) {
                    loadingOverlay.remove();
                }
            }
        }

        function showError(section, message) {
            const sectionElement = document.getElementById(`dashboard-${section}`);
            if (sectionElement) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'alert alert-danger';
                errorDiv.textContent = message;
                sectionElement.appendChild(errorDiv);
            }
        }
        
        // Additional utility functions
        function calculateDeliveryRate(stats) {
            if (!stats.sentMessages || stats.sentMessages === 0) return '0.0';
            const delivered = stats.messageStatus?.delivered || 0;
            return ((delivered / stats.sentMessages) * 100).toFixed(1);
        }

        function updateElement(id, value) {
            const element = document.getElementById(id);
            if (element) {
                if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                    element.value = value;
                } else {
                    element.textContent = value;
                }
                console.log(`Updated ${id}:`, value); // Debug log
            } else {
                console.log(`Element with id '${id}' not found (this is normal if not on overview page)`); // Debug log
            }
        }
        
        // makeApiCall is now globally available from above
        
        // Section data loading functions
        async function loadSessionsData() {
            try {
                showLoading('sessions');

                // Check if user is logged in
                const isLoggedIn = sessionStorage.getItem('isLoggedIn') === 'true';
                if (!isLoggedIn) {
                    showError('sessions', 'Please log in to view sessions');
                    hideLoading('sessions');
                    return;
                }

                // Check if API key exists for WhatsApp endpoints
                let apiKey = '';
                
                // Check window.currentUser first (updated by dashboard)
                if (window.currentUser && window.currentUser.apiKey) {
                    apiKey = window.currentUser.apiKey;
                }
                
                // Also check sessionStorage for the most recent user data
                const storedUser = sessionStorage.getItem('currentUser');
                if (storedUser && !apiKey) {
                    try {
                        const userObj = JSON.parse(storedUser);
                        if (userObj.apiKey && userObj.apiKey !== 'Not generated') {
                            apiKey = userObj.apiKey;
                        }
                    } catch (e) {
                        console.error('Error parsing stored user:', e);
                    }
                }
                
                // No API key check needed - using JWT authentication from cookies
                const response = await makeApiCall('/api/whatsapp/sessions');
                console.log('Sessions API response:', response);
                
                // Handle different response structures
                const sessions = response.data?.sessions || response.sessions || response.data || response;
                
                // Ensure sessions is an array
                if (!Array.isArray(sessions)) {
                    console.error('Sessions data is not an array:', sessions);
                    showError('sessions', 'Invalid sessions data format');
                    hideLoading('sessions');
                    return;
                }

                // Update sessions container
                const sessionsContainer = document.getElementById('sessions-container');
                if (!sessionsContainer) {
                    console.error('Sessions container not found');
                    showError('sessions', 'Sessions container not found in DOM');
                    hideLoading('sessions');
                    return;
                }

                if (sessions && sessions.length > 0) {
                    sessionsContainer.innerHTML = sessions.map((session, index) => `
                        <div class="col-md-6">
                            <div class="card session-card">
                                <div class="card-body">
                                    <div class="d-flex justify-content-between align-items-start mb-3">
                                        <h5>Session #${index + 1}</h5>
                                        <span class="badge ${session.status === 'connected' ? 'bg-success' : session.status === 'connecting' ? 'bg-warning' : 'bg-secondary'}">
                                            ${session.status ? session.status.charAt(0).toUpperCase() + session.status.slice(1) : 'Unknown'}
                                        </span>
                                    </div>
                                    <p><strong>Session ID:</strong> ${session.sessionId}</p>
                                    <p><strong>Phone:</strong> ${session.phoneNumber || 'Not connected'}</p>
                                    <p><strong>Status:</strong> ${session.status || 'unknown'}</p>
                                    <p><strong>Created:</strong> ${new Date(session.createdAt).toLocaleDateString()}</p>
                                    <div class="btn-group" role="group">
                                        ${session.status === 'connected' ? 
                                            `<button class="btn btn-outline-danger btn-sm disconnect-session-btn" data-session-id="${session.sessionId}">
                                                <i class="fas fa-unlink me-1"></i>Disconnect
                                            </button>` : 
                                            `<button class="btn btn-outline-primary btn-sm connect-session-btn" data-session-id="${session.sessionId}">
                                                <i class="fas fa-link me-1"></i>Connect
                                            </button>`
                                        }
                                        <button class="btn btn-outline-danger btn-sm delete-session-btn" data-session-id="${session.sessionId}" title="Delete Session">
                                            <i class="fas fa-trash me-1"></i>Delete
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    sessionsContainer.innerHTML = `
                        <div class="col-12">
                            <div class="text-center py-5">
                                <i class="fas fa-mobile-alt fa-3x text-muted mb-3"></i>
                                <h5 class="text-muted">No sessions yet</h5>
                                <p class="text-muted">Create your first WhatsApp session to get started</p>
                                <button class="btn btn-primary" id="create-first-session-btn">
                                    <i class="fas fa-plus me-2"></i>Create Session
                                </button>
                            </div>
                        </div>
                    `;
                }

                // Re-initialize session buttons after updating the DOM
                initializeSessionButtons();

                hideLoading('sessions');
            } catch (error) {
                console.error('Error loading sessions data:', error);
                hideLoading('sessions');

                if (error.message.includes('log in')) {
                    showError('sessions', 'Please log in to view sessions');
                } else {
                    showError('sessions', 'Failed to load sessions data: ' + error.message);
                }
            }
        }
        
        // Make loadSessionsData globally available
        window.loadSessionsData = loadSessionsData;

        // Load templates data
        async function loadTemplatesData() {
            try {
                const response = await makeApiCall('/api/templates');
                
                if (!response.success || !response.data) {
                    console.error('Failed to load templates');
                    return;
                }

                const templates = response.data;
                
                // Separate templates by category
                const allTemplates = templates;
                const marketingTemplates = templates.filter(t => t.category === 'marketing');
                const otpTemplates = templates.filter(t => t.category === 'otp');
                const customTemplates = templates.filter(t => t.category === 'custom');

                // Render all templates
                renderTemplates('all-templates-container', allTemplates);
                renderTemplates('marketing-templates-container', marketingTemplates);
                renderTemplates('otp-templates-container', otpTemplates);
                renderTemplates('custom-templates-container', customTemplates);

            } catch (error) {
                console.error('Error loading templates:', error);
            }
        }

        function renderTemplates(containerId, templates) {
            const container = document.getElementById(containerId);
            if (!container) return;

            if (templates.length === 0) {
                const category = containerId.replace('-templates-container', '').replace('all', 'template');
                container.innerHTML = `
                    <div class="col-12 text-center py-5">
                        <i class="fas fa-file-alt fa-3x text-muted mb-3"></i>
                        <h5 class="text-muted">No ${category}s yet</h5>
                        <p class="text-muted">Click "New Template" to create your first template</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = templates.map(template => `
                <div class="col-md-6 col-lg-4">
                    <div class="card template-card h-100" style="position: relative;" data-category="${template.category}">
                        <span class="badge bg-${template.category === 'marketing' ? 'primary' : template.category === 'otp' ? 'warning' : 'secondary'}">
                            ${template.category.toUpperCase()}
                        </span>
                        <div class="card-body">
                            <h5 class="card-title">${template.name}</h5>
                            <p class="card-text text-muted small" style="max-height: 100px; overflow: hidden;">
                                ${template.content.substring(0, 150)}${template.content.length > 150 ? '...' : ''}
                            </p>
                            ${template.variables.length > 0 ? `
                                <div class="mb-2">
                                    <small class="text-muted">Variables:</small>
                                    ${template.variables.map(v => `<span class="badge bg-light text-dark me-1">{{${v}}}</span>`).join('')}
                                </div>
                            ` : ''}
                            <div class="d-flex justify-content-between align-items-center mt-3">
                                <small class="text-muted">
                                    <i class="fas fa-chart-line me-1"></i>${template.usageCount || 0} uses
                                </small>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-primary" data-template-action="preview" data-template-id="${template._id}">
                                        <i class="fas fa-eye"></i>
                                    </button>
                                    <button class="btn btn-outline-secondary" data-template-action="edit" data-template-id="${template._id}">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button class="btn btn-outline-danger" data-template-action="delete" data-template-id="${template._id}">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Make loadTemplatesData globally available
        window.loadTemplatesData = loadTemplatesData;

        // Load messages data
        async function loadMessagesData() {
            try {
                showLoading('messages');
                const response = await makeApiCall('/api/analytics/messages?period=7d');
                
                const timeSeries = response.data?.timeSeries || response.timeSeries || [];
                
                if (!Array.isArray(timeSeries)) {
                    console.error('TimeSeries data is not an array:', timeSeries);
                    showError('messages', 'Invalid messages data format');
                    hideLoading('messages');
                    return;
                }

                const messagesTable = document.getElementById('messages-table');
                if (timeSeries && timeSeries.length > 0) {
                    messagesTable.innerHTML = timeSeries.slice(0, 10).map((item, index) => `
                        <tr>
                            <td><code>msg_${index + 1}</code></td>
                            <td>+1234567890</td>
                            <td>Sample message from ${item._id}</td>
                            <td><span class="badge bg-success">Delivered</span></td>
                            <td>${new Date().toLocaleTimeString()}</td>
                        </tr>
                    `).join('');
                } else {
                    messagesTable.innerHTML = `
                        <tr>
                            <td colspan="5" class="text-center text-muted">No messages found</td>
                        </tr>
                    `;
                }

                hideLoading('messages');
            } catch (error) {
                console.error('Error loading messages data:', error);
                hideLoading('messages');
                showError('messages', 'Failed to load messages data');
            }
        }


        async function loadAnalyticsData() {
            try {
                showLoading('analytics');
                const response = await makeApiCall('/api/analytics/dashboard?period=30d');
                
                const stats = response.data?.overview || response.overview || {};
                
                // Update analytics charts and data
                updateElement('analytics-messages', (stats.totalMessages || 0).toLocaleString());
                updateElement('analytics-sessions', stats.totalSessions || 0);
                updateElement('analytics-delivery-rate', calculateDeliveryRate(stats) + '%');

                hideLoading('analytics');
            } catch (error) {
                console.error('Error loading analytics data:', error);
                hideLoading('analytics');
                showError('analytics', 'Failed to load analytics data');
            }
        }

        async function loadBillingData() {
            try {
                showLoading('billing');
                const response = await makeApiCall('/api/auth/profile');
                
                const user = response.data?.user || response.user || response;
                const subscription = user.subscription || {};
                
                // Update billing information
                updateElement('current-plan', subscription.plan || 'Free');
                updateElement('billing-status', subscription.status || 'Active');

                hideLoading('billing');
            } catch (error) {
                console.error('Error loading billing data:', error);
                hideLoading('billing');
                showError('billing', 'Failed to load billing data');
            }
        }

        async function loadProfileData() {
            try {
                console.log('loadProfileData called');
                showLoading('profile');
                const response = await makeApiCall('/api/auth/profile');
                console.log('Profile API response:', response);
                
                const user = response.data?.user || response.user || response;
                console.log('User data:', user);
                
                // Update profile form fields
                updateElement('profile-name', user.name || '');
                updateElement('profile-email', user.email || '');
                updateElement('profile-phone', user.phone || '');
                updateElement('profile-company', user.company || '');
                
                // Update verification status
                const verificationBadge = document.getElementById('verification-status');
                if (verificationBadge) {
                    if (user.isVerified) {
                        verificationBadge.innerHTML = '<span class="badge bg-success"><i class="fas fa-check-circle"></i> Verified</span>';
                    } else {
                        verificationBadge.innerHTML = '<span class="badge bg-warning"><i class="fas fa-exclamation-circle"></i> Unverified</span>';
                    }
                }

                hideLoading('profile');
            } catch (error) {
                console.error('Error loading profile data:', error);
                hideLoading('profile');
                showError('profile', 'Failed to load profile data');
            }
        }
        
        // Load section-specific data
        async function loadSectionData(section) {
            console.log('loadSectionData called with section:', section);
            switch (section) {
                case 'overview':
                    await loadDashboardData();
                    break;
                case 'sessions':
                    await loadSessionsData();
                    break;
                case 'messages':
                    // Messages data will be loaded by initializeMessagesPage()
                    console.log('Messages section loaded - data will be loaded by initializeMessagesPage()');
                    break;
                case 'templates':
                    console.log('Templates section loaded - loading templates');
                    await loadTemplatesData();
                    break;
                case 'chatbot':
                    console.log('Chatbot section loaded - initializing chatbot management');
                    await loadChatbotData();
                    break;
                case 'analytics':
                    await loadAnalyticsData();
                    break;
                case 'billing':
                    await loadBillingData();
                    break;
                case 'profile':
                    console.log('Loading profile data...');
                    await loadProfileData();
                    break;
            }
        }
        
        // Load section page dynamically
        async function loadSectionPage(section) {
            console.log('loadSectionPage called with section:', section);
            console.log('Auth token available:', !!sessionStorage.getItem('authToken'));
            
            try {
                // Show loading state
                const contentContainer = document.getElementById('dashboard-content-container');
                if (contentContainer) {
                    contentContainer.innerHTML = `
                        <div class="text-center py-5">
                            <div class="spinner-border text-primary mb-3" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="text-muted">Loading ${section} page...</p>
                        </div>
                    `;
                }

                // Load the section page content
                console.log(`Fetching section: /api/dashboard/section/${section}`);
                const response = await fetch(`/api/dashboard/section/${section}`, {
                    headers: {
                        'Authorization': `Bearer ${sessionStorage.getItem('authToken')}`,
                        'Content-Type': 'application/json'
                    }
                });
                console.log(`Response status: ${response.status} ${response.statusText}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Error response body:`, errorText);
                    throw new Error(`Failed to load ${section} page: ${response.statusText} - ${errorText}`);
                }
                
                const html = await response.text();
                if (contentContainer) {
                    contentContainer.innerHTML = html;
                    
                    // Execute any scripts in the loaded content
                    const scripts = contentContainer.querySelectorAll('script');
                    console.log(`Found ${scripts.length} script(s) to execute in ${section} section`);
                    scripts.forEach((oldScript, index) => {
                        const newScript = document.createElement('script');
                        // Copy all attributes
                        Array.from(oldScript.attributes).forEach(attr => {
                            newScript.setAttribute(attr.name, attr.value);
                        });
                        // Copy the script content
                        newScript.textContent = oldScript.textContent;
                        // Replace old script with new one to execute it
                        oldScript.parentNode.replaceChild(newScript, oldScript);
                        console.log(`Executed script ${index + 1}/${scripts.length}`);
                    });
                }

                // Load section-specific data after page is loaded
                await loadSectionData(section);
                
                // Re-initialize API key buttons and forms if we're on the overview section
                if (section === 'overview') {
                    setTimeout(() => {
                        initializeApiKeyButtons();
                        initializeOverviewForms();
                        // Also refresh session dropdowns when overview loads
                        loadOverviewSessionDropdowns();
                    }, 100);
                }
                
                // Initialize session buttons if we're on the sessions section
                if (section === 'sessions') {
                    setTimeout(() => {
                        initializeSessionButtons();
                    }, 100);
                }
                
                // Initialize messages page if we're on the messages section
                if (section === 'messages') {
                    console.log('Messages section detected, initializing...');
                    setTimeout(() => {
                        console.log('Checking for window.initializeMessagesPage:', typeof window.initializeMessagesPage);
                        if (window.initializeMessagesPage) {
                            console.log('Calling window.initializeMessagesPage()');
                            window.initializeMessagesPage();
                        } else {
                            console.error('window.initializeMessagesPage not found!');
                            // Try to manually call the functions
                            console.log('Attempting manual initialization...');
                            
                            // Try the manual session loader as a fallback
                            if (typeof window.manualLoadSessions === 'function') {
                                console.log('Using manual session loader...');
                                window.manualLoadSessions();
                            } else {
                                console.log('Manual session loader not available, creating inline fallback...');
                                // Create inline fallback function
                                try {
                                    console.log('Creating inline session loader...');
                                    const sessionFilter = document.getElementById('session-filter');
                                    if (sessionFilter) {
                                        console.log('Found session filter dropdown');
                                        sessionFilter.innerHTML = '<option value="">Loading sessions...</option>';
                                        
                                        // Make API call directly
                                        window.makeApiCall('/api/whatsapp/sessions').then(response => {
                                            console.log('Inline API Response:', response);
                                            
                                            sessionFilter.innerHTML = '<option value="">All Sessions</option>';
                                            
                                            let sessions = [];
                                            if (response && response.success) {
                                                // Handle different response formats
                                                if (response.sessions && Array.isArray(response.sessions)) {
                                                    sessions = response.sessions;
                                                } else if (response.data && Array.isArray(response.data)) {
                                                    sessions = response.data;
                                                } else if (response.data && response.data.sessions && Array.isArray(response.data.sessions)) {
                                                    sessions = response.data.sessions;
                                                }
                                            } else if (Array.isArray(response)) {
                                                sessions = response;
                                            }
                                            
                                            console.log('Response parsing details:', {
                                                hasSuccess: !!response.success,
                                                hasSessions: !!response.sessions,
                                                hasData: !!response.data,
                                                sessionsIsArray: Array.isArray(response.sessions),
                                                dataIsArray: Array.isArray(response.data),
                                                responseKeys: Object.keys(response || {}),
                                                sessionsLength: response.sessions ? response.sessions.length : 'N/A'
                                            });
                                            
                                            console.log('Inline sessions to add:', sessions);
                                            
                                            sessions.forEach(session => {
                                                const option = document.createElement('option');
                                                option.value = session.sessionId || session.id;
                                                
                                                // Show connection status
                                                let statusText = '';
                                                if (session.isConnected === true || session.connected === true || session.status === 'connected' || session.status === 'ready') {
                                                    statusText = ' ✓ Connected';
                                                } else {
                                                    statusText = ' ✗ Disconnected';
                                                }
                                                
                                                const phoneText = session.phoneNumber ? ` (${session.phoneNumber})` : '';
                                                option.textContent = `${session.sessionId || session.id}${phoneText}${statusText}`;
                                                sessionFilter.appendChild(option);
                                            });
                                            
                                            console.log(`✅ Inline: Added ${sessions.length} sessions to dropdown`);
                                            
                                            // Also load messages data and initialize buttons
                                            setTimeout(() => {
                                                loadInlineMessagesData(sessions);
                                                window.initializeMessageButtons();
                                            }, 500);
                                            
                                        }).catch(error => {
                                            console.error('❌ Inline API call failed:', error);
                                            sessionFilter.innerHTML = '<option value="">Error loading sessions</option>';
                                        });
                                    } else {
                                        console.error('Session filter dropdown not found');
                                    }
                                } catch (error) {
                                    console.error('Inline fallback failed:', error);
                                }
                            }
                        }
                    }, 100);
                }
                
                // Initialize analytics page if we're on the analytics section
                if (section === 'analytics') {
                    console.log('Analytics section detected, initializing...');
                    setTimeout(() => {
                        if (window.initializeAnalyticsPage) {
                            console.log('Calling window.initializeAnalyticsPage()');
                            window.initializeAnalyticsPage();
                        } else {
                            console.log('window.initializeAnalyticsPage not found, initializing manually...');
                            // Initialize analytics manually
                            initializeAnalyticsManually();
                        }
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error loading section page:', error);
                const contentContainer = document.getElementById('dashboard-content-container');
                if (contentContainer) {
                    contentContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            Error loading ${section} page: ${error.message}
                        </div>
                    `;
                }
            }
        }
        
        // Load dashboard overview data
        async function loadDashboardData() {
            try {
                showLoading('overview');

                // Check if user is logged in
                const isLoggedIn = sessionStorage.getItem('isLoggedIn') === 'true';
                if (!isLoggedIn) {
                    // Show default data for non-logged in users
                    updateElement('messages-sent', '0');
                    updateElement('active-sessions', '0');
                    updateElement('delivery-rate', '0%');
                    updateElement('total-sessions', '0');
                    updateElement('plan-badge', 'Free Plan');
                    loadApiKeyData();
                    hideLoading('overview');
                    return;
                }

                // Check if JWT token exists
                const token = sessionStorage.getItem('authToken');
                if (!token) {
                    updateElement('messages-sent', '0');
                    updateElement('active-sessions', '0');
                    updateElement('delivery-rate', '0%');
                    updateElement('total-sessions', '0');
                    updateElement('plan-badge', 'Free Plan');
                    loadApiKeyData();
                    hideLoading('overview');
                    return;
                }

                const response = await makeApiCall('/api/analytics/dashboard?period=30d');
                const stats = response.data.overview;

                // Update stats cards
                updateElement('messages-sent', (stats.totalMessages || 0).toLocaleString());
                updateElement('active-sessions', stats.activeSessions || 0);
                updateElement('delivery-rate', calculateDeliveryRate(stats) + '%');
                updateElement('total-sessions', stats.totalSessions || 0);

                // Update message limit text
                const messageLimit = stats.messageLimit || 10000;
                const messageCount = stats.messageCount || stats.totalMessages || 0;
                updateElement('message-limit-text', `of ${messageLimit.toLocaleString()} this month (${messageCount.toLocaleString()} used)`);

                // Update plan badge
                updateElement('plan-badge', stats.plan ? stats.plan.charAt(0).toUpperCase() + stats.plan.slice(1) + ' Plan' : 'Free Plan');

                // Load additional overview data
                await loadApiKeyData();
                // Load session dropdowns silently (don't show errors if no sessions exist)
                try {
                    await loadOverviewSessionDropdowns();
                } catch (error) {
                    console.log('Session dropdowns not available (this is normal if no sessions exist yet):', error.message);
                }
                await loadUsageChart();
                await loadBotConfiguration();

                hideLoading('overview');
            } catch (error) {
                console.error('Error loading dashboard data:', error);
                hideLoading('overview');

                // Show user-friendly error message
                if (error.message.includes('log in')) {
                    showError('overview', 'Please log in to view dashboard data');
                } else {
                    showError('overview', 'Failed to load dashboard data: ' + error.message);
                }
            }
        }

        // Load API key data and buttons
        async function loadApiKeyData() {
            try {
                const apiKeyInput = document.getElementById('api-key');
                const apiKeyButtonsContainer = document.getElementById('api-key-buttons');
                
                if (!apiKeyInput || !apiKeyButtonsContainer) return;

                // Fetch fresh user data from backend to get the latest API key
                let currentUser = window.currentUser || {};
                let hasApiKey = false;
                
                try {
                    const token = sessionStorage.getItem('authToken');
                    if (token) {
                        const response = await fetch('/api/auth/profile', {
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.user) {
                                currentUser = data.user;
                                // Update window.currentUser with fresh data
                                window.currentUser = currentUser;
                                // Also update sessionStorage
                                sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
                            }
                        }
                    }
                } catch (fetchError) {
                    console.error('Error fetching user profile:', fetchError);
                    // Fall back to cached user data
                }

                // Check if API key exists in the database
                hasApiKey = currentUser.apiKey && currentUser.apiKey !== 'Not generated' && currentUser.apiKey.trim() !== '';

                if (hasApiKey) {
                    apiKeyInput.value = currentUser.apiKey;
                    apiKeyButtonsContainer.innerHTML = `
                        <button class="btn btn-outline-secondary" type="button" id="toggle-api-key">
                            <i class="fas fa-eye" id="api-key-icon"></i>
                        </button>
                        <button class="btn btn-outline-secondary" type="button" id="copy-api-key">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="btn btn-warning" type="button" id="regenerate-api-key" 
                                data-bs-toggle="tooltip" data-bs-placement="top" 
                                title="Generate a new API key (this will invalidate the current key)">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    `;
                } else {
                    apiKeyInput.value = 'Not generated';
                    apiKeyButtonsContainer.innerHTML = `
                        <button class="btn btn-primary" type="button" id="generate-api-key">
                            <i class="fas fa-plus me-2"></i>Generate Key
                        </button>
                    `;
                }

                // Re-initialize API key button functionality
                initializeApiKeyButtons();
                
                // Initialize generate button if it was just created
                if (!hasApiKey) {
                    setTimeout(() => {
                        initializeGenerateApiKeyButton();
                    }, 100);
                }
            } catch (error) {
                console.error('Error loading API key data:', error);
            }
        }

        // Load session dropdowns for overview forms
        async function loadOverviewSessionDropdowns() {
            try {
                console.log('=== Loading overview session dropdowns ===');
                
                // Wait for DOM elements to be ready with retry logic
                let retries = 0;
                const maxRetries = 10;
                let quickSessionSelect, bulkSessionSelect, botDefaultSessionSelect;
                
                while (retries < maxRetries) {
                    quickSessionSelect = document.getElementById('quick-session-select');
                    bulkSessionSelect = document.getElementById('bulk-session-select');
                    botDefaultSessionSelect = document.getElementById('bot-default-session');
                    
                    if (quickSessionSelect || bulkSessionSelect || botDefaultSessionSelect) {
                        break;
                    }
                    
                    console.log(`Waiting for dropdown elements... retry ${retries + 1}/${maxRetries}`);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    retries++;
                }

                console.log('Dropdown elements found:', {
                    quickSessionSelect: !!quickSessionSelect,
                    bulkSessionSelect: !!bulkSessionSelect,
                    botDefaultSessionSelect: !!botDefaultSessionSelect,
                    retriesNeeded: retries
                });

                if (!quickSessionSelect && !bulkSessionSelect && !botDefaultSessionSelect) {
                    console.log('No dropdown elements found after retries, skipping session loading');
                    return;
                }

                // Check if API key is available
                const apiKey = window.getApiKey();
                console.log('API Key available:', !!apiKey);
                if (!apiKey) {
                    console.error('No API key found - cannot load sessions');
                    if (quickSessionSelect) {
                        quickSessionSelect.innerHTML = '<option value="">No API key - Generate one first</option>';
                    }
                    return;
                }

                // Get sessions data
                console.log('Fetching sessions from API...');
                let sessionsResponse;
                try {
                    sessionsResponse = await makeApiCall('/api/whatsapp/sessions');
                    console.log('Sessions API response:', sessionsResponse);
                } catch (apiError) {
                    // Silently handle API errors - this is normal for new users without sessions
                    console.log('Sessions API call failed (this is normal if no sessions exist):', apiError.message);
                    sessionsResponse = { success: true, sessions: [], data: [] };
                }
                console.log('Response type:', typeof sessionsResponse);
                console.log('Response keys:', Object.keys(sessionsResponse || {}));

                // Handle different possible response structures
                let sessions = [];
                if (sessionsResponse.success && sessionsResponse.sessions) {
                    // New API format: {success: true, sessions: [...]}
                    sessions = Array.isArray(sessionsResponse.sessions) ? sessionsResponse.sessions : [];
                } else if (sessionsResponse.success && sessionsResponse.data) {
                    // Old API format: {success: true, data: [...]}
                    sessions = Array.isArray(sessionsResponse.data) ? sessionsResponse.data : 
                              (sessionsResponse.data.sessions || []);
                } else if (Array.isArray(sessionsResponse.data)) {
                    sessions = sessionsResponse.data;
                } else if (Array.isArray(sessionsResponse)) {
                    sessions = sessionsResponse;
                }
                
                console.log('Response structure analysis:', {
                    hasSuccess: !!sessionsResponse.success,
                    hasSessions: !!sessionsResponse.sessions,
                    hasData: !!sessionsResponse.data,
                    sessionsIsArray: Array.isArray(sessionsResponse.sessions),
                    dataIsArray: Array.isArray(sessionsResponse.data),
                    sessionsLength: sessionsResponse.sessions?.length || 0,
                    dataLength: sessionsResponse.data?.length || 0
                });

                console.log('Parsed sessions:', sessions);
                console.log('Total sessions found:', sessions.length);

                // Filter connected sessions - check multiple possible status fields
                // Also include sessions that are isConnected=true but have pending status (temporary fix)
                const connectedSessions = sessions.filter(session => {
                    const isConnectedByFlag = session.isConnected === true || session.connected === true;
                    const isConnectedByStatus = session.status === 'connected' || session.status === 'ready';
                    const hasPendingButConnected = session.isConnected === true && session.status === 'pending' && session.phoneNumber;
                    
                    console.log(`Session ${session.sessionId || session.id}:`, {
                        isConnected: session.isConnected,
                        status: session.status,
                        phoneNumber: session.phoneNumber,
                        isConnectedByFlag,
                        isConnectedByStatus,
                        hasPendingButConnected,
                        willInclude: isConnectedByFlag || isConnectedByStatus || hasPendingButConnected
                    });
                    
                    return isConnectedByFlag || isConnectedByStatus || hasPendingButConnected;
                });

                console.log('Connected sessions:', connectedSessions);
                console.log('Connected sessions count:', connectedSessions.length);

                // Populate quick message session dropdown
                if (quickSessionSelect) {
                    quickSessionSelect.innerHTML = '<option value="">Select a connected session</option>';
                    
                    if (connectedSessions.length === 0) {
                        const noSessionOption = document.createElement('option');
                        noSessionOption.value = '';
                        noSessionOption.textContent = 'No connected sessions available';
                        noSessionOption.disabled = true;
                        quickSessionSelect.appendChild(noSessionOption);
                    } else {
                        connectedSessions.forEach(session => {
                            const option = document.createElement('option');
                            option.value = session.sessionId || session.id;
                            option.textContent = `${session.sessionId || session.id} (${session.phoneNumber || session.phone || 'No phone'})`;
                            quickSessionSelect.appendChild(option);
                        });
                    }
                    console.log('Quick session dropdown populated with', quickSessionSelect.options.length - 1, 'sessions');
                }

                // Populate bulk upload session dropdown
                if (bulkSessionSelect) {
                    bulkSessionSelect.innerHTML = '<option value="">Select a connected session</option>';
                    
                    if (connectedSessions.length === 0) {
                        const noSessionOption = document.createElement('option');
                        noSessionOption.value = '';
                        noSessionOption.textContent = 'No connected sessions available';
                        noSessionOption.disabled = true;
                        bulkSessionSelect.appendChild(noSessionOption);
                    } else {
                        connectedSessions.forEach(session => {
                            const option = document.createElement('option');
                            option.value = session.sessionId || session.id;
                            option.textContent = `${session.sessionId || session.id} (${session.phoneNumber || session.phone || 'No phone'})`;
                            bulkSessionSelect.appendChild(option);
                        });
                    }
                    console.log('Bulk session dropdown populated with', bulkSessionSelect.options.length - 1, 'sessions');
                }

                // Populate bot default session dropdown
                if (botDefaultSessionSelect) {
                    botDefaultSessionSelect.innerHTML = '<option value="">Select default session for bot</option>';
                    
                    if (connectedSessions.length === 0) {
                        const noSessionOption = document.createElement('option');
                        noSessionOption.value = '';
                        noSessionOption.textContent = 'No connected sessions available';
                        noSessionOption.disabled = true;
                        botDefaultSessionSelect.appendChild(noSessionOption);
                    } else {
                        connectedSessions.forEach(session => {
                            const option = document.createElement('option');
                            option.value = session.sessionId || session.id;
                            option.textContent = `${session.sessionId || session.id} (${session.phoneNumber || session.phone || 'No phone'})`;
                            botDefaultSessionSelect.appendChild(option);
                        });
                    }
                    console.log('Bot session dropdown populated with', botDefaultSessionSelect.options.length - 1, 'sessions');
                }

                // Log info if no connected sessions (this is normal for new users, not an error)
                if (connectedSessions.length === 0) {
                    console.log('No connected sessions found. Users can create sessions after generating an API key.');
                }

            } catch (error) {
                // Only log error, don't show toast - this is expected for new users without sessions
                console.log('Session dropdowns not available:', error.message);
                
                // Silently update dropdowns to show no sessions available
                const dropdowns = [
                    document.getElementById('quick-session-select'),
                    document.getElementById('bulk-session-select'),
                    document.getElementById('bot-default-session')
                ];

                dropdowns.forEach(dropdown => {
                    if (dropdown) {
                        dropdown.innerHTML = '<option value="">No sessions available</option>';
                    }
                });
            }
        }

        // Load usage analytics chart
        async function loadUsageChart() {
            try {
                const chartCanvas = document.getElementById('messagesChart');
                if (!chartCanvas) {
                    console.log('Chart canvas not found');
                    return;
                }

                // Wait for Chart.js to be available
                let chartRetries = 0;
                const maxRetries = 10;
                
                while (typeof Chart === 'undefined' && chartRetries < maxRetries) {
                    console.log(`Waiting for Chart.js to load... (attempt ${chartRetries + 1})`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    chartRetries++;
                }

                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded after waiting, skipping chart creation');
                    showChartFallback(chartCanvas, 'Chart.js library not loaded');
                    return;
                }

                // Ensure canvas has proper dimensions
                if (chartCanvas.width === 0 || chartCanvas.height === 0) {
                    // Set default dimensions if not set
                    chartCanvas.width = chartCanvas.offsetWidth || 400;
                    chartCanvas.height = chartCanvas.offsetHeight || 300;
                }

                // Get message analytics data
                const analyticsResponse = await makeApiCall('/api/analytics/messages?period=30d');
                const timeSeriesData = analyticsResponse.data.timeSeries || [];

                // Prepare chart data
                const labels = timeSeriesData.map(item => {
                    const date = new Date(item._id);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });
                
                const sentData = timeSeriesData.map(item => item.sent || 0);
                const receivedData = timeSeriesData.map(item => item.received || 0);

                // Safely destroy existing chart
                if (window.messagesChart && typeof window.messagesChart.destroy === 'function') {
                    try {
                        window.messagesChart.destroy();
                    } catch (destroyError) {
                        console.warn('Error destroying existing chart:', destroyError);
                    }
                    window.messagesChart = null;
                }

                // Create new chart
                const ctx = chartCanvas.getContext('2d');
                window.messagesChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Messages Sent',
                            data: sentData,
                            borderColor: '#007bff',
                            backgroundColor: 'rgba(0, 123, 255, 0.1)',
                            tension: 0.4,
                            fill: true
                        }, {
                            label: 'Messages Received',
                            data: receivedData,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            },
                            x: {
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 20
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0,0,0,0.8)',
                                titleColor: 'white',
                                bodyColor: 'white',
                                borderColor: 'rgba(255,255,255,0.2)',
                                borderWidth: 1
                            }
                        }
                    }
                });

                console.log('Chart created successfully with', timeSeriesData.length, 'data points');
            } catch (error) {
                console.error('Error loading usage chart:', error);
                const chartCanvas = document.getElementById('messagesChart');
                if (chartCanvas) {
                    showChartFallback(chartCanvas, 'Unable to load chart data');
                }
            }
        }

        // Show fallback message in chart area
        function showChartFallback(canvas, message) {
            try {
                // Ensure canvas has dimensions
                if (canvas.width === 0 || canvas.height === 0) {
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = canvas.offsetHeight || 300;
                }

                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Set background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw border
                ctx.strokeStyle = '#dee2e6';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                
                // Draw text
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#6c757d';
                
                // Split long messages into multiple lines
                const words = message.split(' ');
                const maxWidth = canvas.width - 40;
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) lines.push(currentLine);
                
                // Draw lines
                const lineHeight = 20;
                const startY = (canvas.height - (lines.length * lineHeight)) / 2;
                
                lines.forEach((line, index) => {
                    ctx.fillText(line, canvas.width / 2, startY + (index * lineHeight));
                });
                
            } catch (fallbackError) {
                console.error('Error showing chart fallback:', fallbackError);
                // Ultimate fallback - just hide the canvas
                if (canvas.parentElement) {
                    canvas.parentElement.innerHTML = `<div class="text-center text-muted p-4">${message}</div>`;
                }
            }
        }

        // Initialize overview form handlers
        function initializeOverviewForms() {
            // Quick message form
            const quickMessageForm = document.getElementById('quick-message-form');
            if (quickMessageForm) {
                quickMessageForm.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    await sendQuickMessage();
                });
            }

            // Bulk upload form
            const bulkUploadForm = document.getElementById('bulk-upload-form');
            if (bulkUploadForm) {
                bulkUploadForm.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    await handleBulkUpload();
                });
            }

            // Bot configuration form
            const saveBotConfigBtn = document.getElementById('save-bot-config');
            if (saveBotConfigBtn) {
                saveBotConfigBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    await saveBotConfiguration();
                });
            }

            // CSV template download
            const downloadTemplateLink = document.getElementById('download-template');
            if (downloadTemplateLink) {
                downloadTemplateLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    downloadCSVTemplate();
                });
            }

            // Refresh sessions button
            const refreshSessionsBtn = document.getElementById('refresh-sessions-btn');
            if (refreshSessionsBtn) {
                refreshSessionsBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    const originalContent = this.innerHTML;
                    this.disabled = true;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                    try {
                        await loadOverviewSessionDropdowns();
                        console.log('Sessions refreshed successfully');
                    } catch (error) {
                        console.error('Error refreshing sessions:', error);
                    } finally {
                        this.disabled = false;
                        this.innerHTML = originalContent;
                    }
                });
            }

            // Quick action buttons
            const connectNewSessionBtn = document.getElementById('connect-new-session');
            if (connectNewSessionBtn) {
                connectNewSessionBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Navigate to sessions page
                    const sessionsLink = document.querySelector('.sidebar-nav .nav-link[data-section="sessions"]');
                    if (sessionsLink) {
                        sessionsLink.click();
                    }
                });
            }

            // Refresh button is now part of the overview.ejs template


            const exportContactsBtn = document.getElementById('export-contacts');
            if (exportContactsBtn) {
                exportContactsBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    await exportContactList();
                });
            }

            const backupDataBtn = document.getElementById('backup-data');
            if (backupDataBtn) {
                backupDataBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    await backupMessagesData();
                });
            }
        }

        // Send quick message function
        async function sendQuickMessage() {
            const sessionId = document.getElementById('quick-session-select').value;
            const phone = document.getElementById('quick-phone').value;
            const message = document.getElementById('quick-message').value;
            const mediaFile = document.getElementById('quick-media').files[0];

            if (!sessionId || !phone || !message) {
                showToast('Please fill in all required fields', 'warning');
                return;
            }

            try {
                let response;
                
                if (mediaFile) {
                    // Send media message
                    const formData = new FormData();
                    formData.append('to', phone);
                    formData.append('caption', message);
                    formData.append('media', mediaFile);

                    const headers = getApiKeyHeaders();
                    delete headers['Content-Type']; // Let browser set content-type for FormData
                    
                    response = await fetch(`/api/whatsapp/sessions/${sessionId}/media`, {
                        method: 'POST',
                        headers: headers,
                        body: formData
                    });
                } else {
                    // Send text message
                    response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}/messages`, {
                        method: 'POST',
                        body: JSON.stringify({
                            to: phone,
                            message: message
                        })
                    });
                }

                if (response.success || response.ok) {
                    showToast('Message sent successfully!', 'success');
                    // Reset form
                    document.getElementById('quick-message-form').reset();
                } else {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to send message');
                }
            } catch (error) {
                console.error('Error sending message:', error);
                showToast('Failed to send message: ' + error.message, 'error');
            }
        }

        // Handle bulk upload
        async function handleBulkUpload() {
            const sessionId = document.getElementById('bulk-session-select').value;
            const csvFile = document.getElementById('bulk-csv').files[0];

            if (!sessionId || !csvFile) {
                showToast('Please select a session and upload a CSV file', 'warning');
                return;
            }

            if (!csvFile.name.endsWith('.csv')) {
                showToast('Please upload a valid CSV file', 'warning');
                return;
            }

            try {
                // For now, process CSV locally and send individual messages
                const text = await csvFile.text();
                const lines = text.split('\n').filter(line => line.trim());
                
                if (lines.length < 2) {
                    showToast('CSV file must contain at least a header row and one data row', 'warning');
                    return;
                }

                // Parse CSV (simple parsing - assumes phone,message format)
                const messages = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const [phone, message] = line.split(',').map(item => item.replace(/"/g, '').trim());
                        if (phone && message) {
                            messages.push({ phone, message });
                        }
                    }
                }

                if (messages.length === 0) {
                    showToast('No valid messages found in CSV file', 'warning');
                    return;
                }

                if (messages.length > 100) {
                    showToast('Maximum 100 messages allowed per bulk upload', 'warning');
                    return;
                }

                // Send messages individually (until bulk endpoint is implemented)
                let successCount = 0;
                let failCount = 0;

                for (const msg of messages) {
                    try {
                        await makeApiCall(`/api/whatsapp/sessions/${sessionId}/messages`, {
                            method: 'POST',
                            body: JSON.stringify({
                                to: msg.phone,
                                message: msg.message
                            })
                        });
                        successCount++;
                        
                        // Add small delay between messages
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    } catch (error) {
                        console.error(`Failed to send message to ${msg.phone}:`, error);
                        failCount++;
                    }
                }

                showToast(`Bulk upload completed! Successful: ${successCount}, Failed: ${failCount}`, successCount > 0 ? 'success' : 'warning');
                document.getElementById('bulk-upload-form').reset();

                // TODO: Replace with proper bulk endpoint when available
                /*
                const formData = new FormData();
                formData.append('csv', csvFile);

                const headers = getApiKeyHeaders();
                delete headers['Content-Type'];

                const response = await fetch(`/api/whatsapp/sessions/${sessionId}/bulk-messages`, {
                    method: 'POST',
                    headers: headers,
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    alert(`Bulk messages queued successfully! ${result.data.queued} messages will be sent.`);
                    document.getElementById('bulk-upload-form').reset();
                } else {
                    alert('Failed to upload bulk messages: ' + (result.message || 'Unknown error'));
                }
                */
            } catch (error) {
                console.error('Error uploading bulk messages:', error);
                showToast('Failed to upload bulk messages: ' + error.message, 'error');
            }
        }

        // Save bot configuration
        async function saveBotConfiguration() {
            const botName = document.getElementById('bot-name').value;
            const defaultSession = document.getElementById('bot-default-session').value;
            const welcomeMessage = document.getElementById('bot-welcome').value;
            const fallbackMessage = document.getElementById('bot-fallback').value;
            const websiteUrl = document.getElementById('bot-website').value;
            const botEnabled = document.getElementById('bot-enabled').checked;

            if (!botName || !welcomeMessage || !fallbackMessage) {
                showToast('Please fill in all required fields (Bot Name, Welcome Message, Fallback Message)', 'warning');
                return;
            }

            try {
                // For now, save to localStorage until backend endpoint is implemented
                const botConfig = {
                    name: botName,
                    defaultSession: defaultSession,
                    welcomeMessage: welcomeMessage,
                    fallbackMessage: fallbackMessage,
                    websiteUrl: websiteUrl,
                    enabled: botEnabled,
                    lastUpdated: new Date().toISOString()
                };

                localStorage.setItem('botConfiguration', JSON.stringify(botConfig));
                showToast('Bot configuration saved locally! (Backend integration coming soon)', 'info');

                // TODO: Uncomment when backend endpoint is ready
                /*
                const response = await makeApiCall('/api/bot/config', {
                    method: 'POST',
                    body: JSON.stringify(botConfig)
                });

                if (response.success) {
                    showToast('Bot configuration saved successfully!', 'success');
                } else {
                    alert('Failed to save bot configuration: ' + (response.message || 'Unknown error'));
                }
                */
            } catch (error) {
                console.error('Error saving bot configuration:', error);
                alert('Failed to save bot configuration: ' + error.message);
            }
        }

        // Load bot configuration from localStorage
        async function loadBotConfiguration() {
            try {
                const savedConfig = localStorage.getItem('botConfiguration');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    
                    const botNameInput = document.getElementById('bot-name');
                    const defaultSessionSelect = document.getElementById('bot-default-session');
                    const welcomeMessageInput = document.getElementById('bot-welcome');
                    const fallbackMessageInput = document.getElementById('bot-fallback');
                    const websiteUrlInput = document.getElementById('bot-website');
                    const botEnabledInput = document.getElementById('bot-enabled');

                    if (botNameInput) botNameInput.value = config.name || '';
                    if (defaultSessionSelect) defaultSessionSelect.value = config.defaultSession || '';
                    if (welcomeMessageInput) welcomeMessageInput.value = config.welcomeMessage || '';
                    if (fallbackMessageInput) fallbackMessageInput.value = config.fallbackMessage || '';
                    if (websiteUrlInput) websiteUrlInput.value = config.websiteUrl || '';
                    if (botEnabledInput) botEnabledInput.checked = config.enabled || false;
                }
            } catch (error) {
                console.error('Error loading bot configuration:', error);
            }
        }

        // Download CSV template
        function downloadCSVTemplate() {
            const csvContent = 'phone,message\n+1234567890,"Hello, this is a test message"\n+0987654321,"Another test message"';
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bulk_messages_template.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }


        // Export contact list
        async function exportContactList() {
            try {
                const response = await makeApiCall('/api/analytics/contacts?limit=1000');
                
                if (response.success && response.data.contacts) {
                    const contacts = response.data.contacts;
                    const csvContent = 'contact,total_messages,sent_messages,received_messages,last_message_date\n' +
                        contacts.map(contact => 
                            `${contact.contact},${contact.totalMessages},${contact.sentMessages},${contact.receivedMessages},${contact.lastMessageDate}`
                        ).join('\n');

                    const blob = new Blob([csvContent], { type: 'text/csv' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'contacts_export.csv';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                } else {
                    alert('Failed to export contacts: ' + (response.message || 'No contacts found'));
                }
            } catch (error) {
                console.error('Error exporting contacts:', error);
                alert('Failed to export contacts: ' + error.message);
            }
        }

        // Backup messages data
        async function backupMessagesData() {
            try {
                // Try to get messages from analytics endpoint as fallback
                const response = await makeApiCall('/api/analytics/dashboard?period=90d');
                
                if (response.success && response.data) {
                    // Create a basic backup with available data
                    const backupData = {
                        exportDate: new Date().toISOString(),
                        overview: response.data.overview,
                        messageStatus: response.data.messageStatus,
                        messageTypes: response.data.messageTypes,
                        period: response.data.period,
                        note: 'This is a basic backup. Full message export will be available when the messages export endpoint is implemented.'
                    };
                    
                    const jsonContent = JSON.stringify(backupData, null, 2);
                    const blob = new Blob([jsonContent], { type: 'application/json' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `dashboard_backup_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                    showToast('Dashboard data backup created successfully!', 'success');
                } else {
                    showToast('Failed to backup data: No data available', 'warning');
                }

                // TODO: Replace with proper messages export endpoint when available
                /*
                const response = await makeApiCall('/api/messages/export?format=json');
                
                if (response.success && response.data) {
                    const jsonContent = JSON.stringify(response.data, null, 2);
                    const blob = new Blob([jsonContent], { type: 'application/json' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `messages_backup_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                } else {
                    alert('Failed to backup messages: ' + (response.message || 'No messages found'));
                }
                */
            } catch (error) {
                console.error('Error backing up messages:', error);
                alert('Failed to backup messages: ' + error.message);
            }
        }
        
        // Clean up any existing modal backdrops first
        cleanupModalBackdrops();
        
        // Initialize tooltips
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
        var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        })

        // Dashboard tab navigation
        const sidebarLinks = document.querySelectorAll('.sidebar-nav .nav-link[data-section]');
        const contentContainer = document.getElementById('dashboard-content-container');

        sidebarLinks.forEach(link => {
            link.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation(); // Prevent event bubbling to avoid double execution

                // Remove active class from all links
                sidebarLinks.forEach(l => l.classList.remove('active'));
                // Add active class to clicked link
                this.classList.add('active');

                // Get target section
                const targetSection = this.getAttribute('data-section');
                console.log('Switching to section:', targetSection);
                
                // Load the section page dynamically
                loadSectionPage(targetSection);
            });
        });

        // Handle data-view navigation (like API Docs)
        const viewLinks = document.querySelectorAll('.sidebar-nav .nav-link[data-view]');
        viewLinks.forEach(link => {
            link.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();

                const targetView = this.getAttribute('data-view');
                console.log('Switching to view:', targetView);
                
                // Handle different view types
                if (targetView === 'api-docs') {
                    // Redirect to standalone API docs page
                    window.open('/api-docs', '_blank');
                    return;
                }
            });
        });

        // Load initial data with a small delay to ensure authentication is ready
        setTimeout(async () => {
            await loadDashboardData();
            await loadSectionPage('overview');

            // Initialize API key buttons after data is loaded
            initializeApiKeyButtons();
        }, 100);

        // Generate API key functionality - Use event delegation for dynamic buttons
        function handleGenerateApiKeyClick(event) {
            const generateBtn = event.target.closest('#generate-api-key');
            if (!generateBtn) return;
            
            event.preventDefault();
            event.stopPropagation();
            
            // Prevent multiple clicks
            if (generateBtn.disabled) {
                console.log('Button already processing, ignoring click');
                return;
            }
            
            (async function() {
                const originalContent = generateBtn.innerHTML;
                const originalDisabled = generateBtn.disabled;
                
                try {
                    // Show loading state
                    generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Generating...';
                    generateBtn.disabled = true;
                    
                    console.log('Generating API key...');
                    console.log('Auth token exists:', !!getJwtToken());
                    
                    const data = await makeApiCall('/api/auth/generate-api-key', {
                        method: 'POST'
                    });
                    
                    console.log('API key generation response:', data);

                    // Get reference to the API key input field
                    const apiKeyInputField = document.getElementById('api-key');

                    // Update the input field - handle different response structures
                    const apiKey = data?.apiKey || data.apiKey || data.data?.data?.apiKey;
                    if (apiKey && apiKeyInputField) {
                        apiKeyInputField.value = apiKey;

                        // Update currentUser object with new API key
                        if (window.currentUser) {
                            window.currentUser.apiKey = apiKey;
                            console.log('Updated window.currentUser.apiKey:', apiKey);
                        }
                        
                        // Also update sessionStorage
                        const storedUser = sessionStorage.getItem('currentUser');
                        if (storedUser) {
                            try {
                                const userObj = JSON.parse(storedUser);
                                userObj.apiKey = apiKey;
                                sessionStorage.setItem('currentUser', JSON.stringify(userObj));
                                console.log('Updated sessionStorage currentUser with new API key');
                            } catch (e) {
                                console.error('Error updating sessionStorage user:', e);
                            }
                        }

                        // Reload sessions if loadSessions function exists
                        if (typeof loadSessions === 'function') {
                            loadSessions();
                        }
                        
                        // Also call the global refresh function if available
                        if (typeof window.refreshSessions === 'function') {
                            window.refreshSessions();
                        }
                        
                        // If we're currently on the sessions page, reload it
                        const currentSection = document.querySelector('.sidebar-nav .nav-link.active')?.getAttribute('data-section');
                        if (currentSection === 'sessions') {
                            setTimeout(() => {
                                loadSectionPage('sessions');
                            }, 500);
                        }
                    } else if (!apiKey) {
                        throw new Error('API key not found in response');
                    } else {
                        throw new Error('API key input field not found');
                    }

                    // Reload API key data to update the UI with the proper buttons
                    await loadApiKeyData();

                    // Show success message
                    if (typeof showToast === 'function') {
                        showToast('API key generated successfully!', 'success');
                    } else {
                        console.log('✅ API key generated successfully!');
                    }

                    // Reload overview section to update UI only if we're on the overview page
                    const currentSection = document.querySelector('.sidebar-nav .nav-link.active')?.getAttribute('data-section');
                    if (currentSection === 'overview') {
                        setTimeout(async () => {
                            try {
                                // Just reload the session dropdowns, not the entire page
                                await loadOverviewSessionDropdowns();
                            } catch (error) {
                                // Silently handle - this is normal for new users without sessions
                                console.log('Session dropdowns will be available after creating sessions');
                            }
                        }, 300);
                    }

                } catch (error) {
                    console.error('Error generating API key:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        name: error.name
                    });
                    
                    // Restore button state
                    generateBtn.innerHTML = originalContent;
                    generateBtn.disabled = originalDisabled;
                    
                    // Show detailed error message
                    let errorMessage = 'Error generating API key';
                    if (error.message) {
                        errorMessage += ': ' + error.message;
                    }
                    
                    if (error.message && error.message.includes('not logged in')) {
                        errorMessage = 'Please log in to generate an API key';
                        window.location.href = '/login';
                    } else if (error.message && error.message.includes('401')) {
                        errorMessage = 'Session expired. Please log in again';
                        window.location.href = '/login?session=expired';
                    }
                    
                    if (typeof showToast === 'function') {
                        showToast(errorMessage, 'error');
                    } else {
                        showToast(errorMessage, 'error');
                    }
                }
            })();
        }
        
        // Use event delegation for generate button (works even if button is created dynamically)
        document.addEventListener('click', handleGenerateApiKeyClick);
        console.log('✅ Generate API key event delegation set up');
        
        // Also try to initialize immediately if button exists
        function initializeGenerateApiKeyButton() {
            const generateBtn = document.getElementById('generate-api-key');
            if (generateBtn) {
                console.log('✅ Generate API key button found, event delegation already set up');
                // Test click handler
                generateBtn.addEventListener('click', function(e) {
                    console.log('Direct click handler also attached (backup)');
                });
            } else {
                console.log('⚠️ Generate API key button not found yet (will work when created via event delegation)');
            }
        }
        
        // Initialize on page load
        setTimeout(() => {
            initializeGenerateApiKeyButton();
        }, 500);
        
        // Note: loadApiKeyData will call initializeGenerateApiKeyButton when it creates the button

        // Session management - use event delegation for dynamic content
        document.addEventListener('click', async function (e) {
            if (e.target.closest('[data-action="disconnect-session"]')) {
                const button = e.target.closest('[data-action="disconnect-session"]');
                const sessionId = button.getAttribute('data-session');
                
                if (confirm('Are you sure you want to disconnect this session?')) {
                    try {
                        // Show loading state immediately
                        const originalContent = button.innerHTML;
                        button.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Disconnecting...';
                        button.disabled = true;
                        button.classList.add('disabled');

                        // Find session card for visual feedback
                        const sessionCard = button.closest('.session-card') || button.closest('.col-md-6');
                        if (sessionCard) {
                            sessionCard.style.opacity = '0.6';
                            sessionCard.style.transition = 'opacity 0.3s ease';
                        }

                        // Make API call
                        await makeApiCall(`/api/whatsapp/sessions/${sessionId}`, {
                            method: 'DELETE'
                        });

                        // Show success state
                        button.innerHTML = '<i class="fas fa-check me-1"></i>Disconnected';
                        button.classList.remove('btn-outline-danger');
                        button.classList.add('btn-success');

                        // Refresh sessions data after a short delay
                        setTimeout(() => {
                            if (typeof window.loadSessionsData === 'function') {
                                window.loadSessionsData();
                            }
                            // Also refresh overview stats
                            if (typeof loadSessions === 'function') {
                                loadSessions();
                            }
                        }, 1500);

                    } catch (error) {
                        console.error('Error disconnecting session:', error);
                        
                        // Reset button state on error
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        button.classList.remove('disabled');
                        
                        if (sessionCard) {
                            sessionCard.style.opacity = '1';
                        }

                        showToast('Error disconnecting session: ' + error.message, 'error');
                    }
                }
            }
        });

        // Connect session functionality - use event delegation
        document.addEventListener('click', async function (e) {
            if (e.target.closest('[data-action="connect-session"]')) {
                console.log('Connect session button clicked!');
                const button = e.target.closest('[data-action="connect-session"]');
                const sessionId = button.getAttribute('data-session');
                console.log('Session ID:', sessionId);
                
                try {
                    // Show loading state immediately
                    const originalContent = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Connecting...';
                    button.disabled = true;
                    button.classList.add('disabled');

                    // Show QR code modal first
                    showQRCodeModal(sessionId);

                    // Wait a moment for modal to fully render, then start QR code generation
                    setTimeout(async () => {
                        await startQRCodeGeneration(sessionId);
                    }, 500); // Increased timeout to 500ms

                    // Reset button state
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    button.classList.remove('disabled');

                } catch (error) {
                    console.error('Error connecting session:', error);
                    
                    // Reset button state on error
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    button.classList.remove('disabled');

                    // Show error in QR modal
                    const container = document.getElementById('qr-code-container');
                    if (container) {
                        container.innerHTML = `
                            <div class="alert alert-danger">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                Error loading QR code: ${error.message}
                            </div>
                        `;
                    }

                    showToast('Error connecting session: ' + error.message, 'error');
                }
            }
        });

        // Delete session functionality - use event delegation
        document.addEventListener('click', async function (e) {
            if (e.target.closest('[data-action="delete-session"]')) {
                const button = e.target.closest('[data-action="delete-session"]');
                const sessionId = button.getAttribute('data-session');
                
                if (confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                    try {
                        // Show loading state immediately
                        const originalContent = button.innerHTML;
                        button.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Deleting...';
                        button.disabled = true;
                        button.classList.add('disabled');

                        const sessionCard = button.closest('.session-card') || button.closest('.col-md-6');
                        if (sessionCard) {
                            sessionCard.style.opacity = '0.6';
                            sessionCard.style.transition = 'opacity 0.3s ease';
                        }

                        await makeApiCall(`/api/whatsapp/sessions/${sessionId}`, {
                            method: 'DELETE'
                        });

                        button.innerHTML = '<i class="fas fa-check me-1"></i>Deleted';
                        button.classList.remove('btn-outline-danger');
                        button.classList.add('btn-success');

                        // Remove the session card after a short delay
                        setTimeout(() => {
                            if (sessionCard) {
                                sessionCard.remove();
                            }
                            // Reload sessions data
                            if (typeof window.loadSessionsData === 'function') {
                                window.loadSessionsData();
                            }
                            if (typeof loadSessions === 'function') {
                                loadSessions();
                            }
                        }, 1500);

                    } catch (error) {
                        console.error('Error deleting session:', error);
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        button.classList.remove('disabled');
                        
                        if (sessionCard) {
                            sessionCard.style.opacity = '1';
                        }
                        showToast('Error deleting session: ' + error.message, 'error');
                    }
                }
            }
        });

        // Refresh session status functionality - use event delegation
        document.addEventListener('click', async function (e) {
            if (e.target.closest('[data-action="refresh-session"]')) {
                const button = e.target.closest('[data-action="refresh-session"]');
                const sessionId = button.getAttribute('data-session');
                
                try {
                    // Show loading state
                    const originalContent = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Refreshing...';
                    button.disabled = true;
                    button.classList.add('disabled');

                    // Fetch fresh session data
                    const response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}`);
                    
                    if (response.success && response.session) {
                        const session = response.session;
                        
                        // Find the session card
                        const sessionCard = button.closest('.session-card');
                        if (sessionCard) {
                            // Update the status badge
                            const badge = sessionCard.querySelector('.badge');
                            if (badge) {
                                badge.className = `badge bg-${session.status === 'connected' ? 'success' : session.status === 'connecting' ? 'warning' : 'secondary'}`;
                                badge.textContent = session.status.charAt(0).toUpperCase() + session.status.slice(1);
                            }
                            
                            // Update phone number
                            const phoneElement = sessionCard.querySelectorAll('p')[1];
                            if (phoneElement) {
                                phoneElement.innerHTML = `<strong>Phone:</strong> ${session.phoneNumber || 'Not connected'}`;
                            }
                            
                            // Update status text
                            const statusElement = sessionCard.querySelectorAll('p')[2];
                            if (statusElement) {
                                statusElement.innerHTML = `<strong>Status:</strong> ${session.status}`;
                            }
                        }
                        
                        // Show success feedback
                        button.innerHTML = '<i class="fas fa-check me-1"></i>Refreshed';
                        button.classList.remove('btn-outline-secondary');
                        button.classList.add('btn-success');
                        
                        setTimeout(() => {
                            button.innerHTML = originalContent;
                            button.classList.remove('btn-success');
                            button.classList.add('btn-outline-secondary');
                            button.disabled = false;
                            button.classList.remove('disabled');
                        }, 1500);
                        
                        // If status changed to connected, reload session dropdowns
                        if (session.status === 'connected') {
                            setTimeout(() => {
                                if (typeof loadOverviewSessionDropdowns === 'function') {
                                    loadOverviewSessionDropdowns();
                                }
                            }, 500);
                        }
                        
                    } else {
                        throw new Error('Failed to fetch session data');
                    }

                } catch (error) {
                    console.error('Error refreshing session:', error);
                    
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    button.classList.remove('disabled');

                    alert('Error refreshing session: ' + error.message);
                }
            }
        });

        // Template management event handlers
        
        // Create new template button
        document.addEventListener('click', function(e) {
            if (e.target.closest('#create-template-btn')) {
                e.preventDefault();
                const modal = new bootstrap.Modal(document.getElementById('templateModal'));
                document.getElementById('templateModalTitle').innerHTML = '<i class="fas fa-file-alt me-2"></i>Create Template';
                document.getElementById('template-form').reset();
                document.getElementById('template-id').value = '';
                modal.show();
            }
        });

        // Save template button
        document.addEventListener('click', async function(e) {
            if (e.target.closest('#save-template-btn')) {
                e.preventDefault();
                const button = e.target.closest('#save-template-btn');
                const originalContent = button.innerHTML;
                
                try {
                    button.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Saving...';
                    button.disabled = true;

                    const templateId = document.getElementById('template-id').value;
                    const name = document.getElementById('template-name').value;
                    const category = document.getElementById('template-category').value;
                    const content = document.getElementById('template-content').value;
                    const description = document.getElementById('template-description').value;
                    const isActive = document.getElementById('template-active').checked;

                    if (!name || !category || !content) {
                        showToast('Please fill in all required fields', 'warning');
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        return;
                    }

                    const url = templateId ? `/api/templates/${templateId}` : '/api/templates';
                    const method = templateId ? 'PUT' : 'POST';

                    const response = await makeApiCall(url, {
                        method,
                        body: JSON.stringify({
                            name,
                            category,
                            content,
                            description,
                            isActive
                        })
                    });

                    if (response.success) {
                        const modal = bootstrap.Modal.getInstance(document.getElementById('templateModal'));
                        modal.hide();
                        
                        if (typeof showToast === 'function') {
                            showToast(templateId ? 'Template updated successfully!' : 'Template created successfully!', 'success');
                        }
                        
                        // Reload templates
                        if (typeof window.loadTemplatesData === 'function') {
                            await window.loadTemplatesData();
                        }
                    }

                    button.innerHTML = originalContent;
                    button.disabled = false;

                } catch (error) {
                    console.error('Error saving template:', error);
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    alert('Error saving template: ' + error.message);
                }
            }
        });

        // Edit template
        document.addEventListener('click', async function(e) {
            if (e.target.closest('[data-action="edit-template"]')) {
                e.preventDefault();
                const button = e.target.closest('[data-action="edit-template"]');
                const templateId = button.getAttribute('data-template-id');

                try {
                    const response = await makeApiCall(`/api/templates/${templateId}`);
                    
                    if (response.success && response.data) {
                        const template = response.data;
                        
                        document.getElementById('template-id').value = template._id;
                        document.getElementById('template-name').value = template.name;
                        document.getElementById('template-category').value = template.category;
                        document.getElementById('template-content').value = template.content;
                        document.getElementById('template-description').value = template.description || '';
                        document.getElementById('template-active').checked = template.isActive;
                        
                        document.getElementById('templateModalTitle').innerHTML = '<i class="fas fa-edit me-2"></i>Edit Template';
                        
                        const modal = new bootstrap.Modal(document.getElementById('templateModal'));
                        modal.show();
                    }
                } catch (error) {
                    console.error('Error loading template:', error);
                    alert('Error loading template: ' + error.message);
                }
            }
        });

        // Delete template
        document.addEventListener('click', async function(e) {
            if (e.target.closest('[data-action="delete-template"]')) {
                e.preventDefault();
                const button = e.target.closest('[data-action="delete-template"]');
                const templateId = button.getAttribute('data-template-id');

                if (!confirm('Are you sure you want to delete this template? This action cannot be undone.')) {
                    return;
                }

                try {
                    const originalContent = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    button.disabled = true;

                    await makeApiCall(`/api/templates/${templateId}`, {
                        method: 'DELETE'
                    });

                    if (typeof showToast === 'function') {
                        showToast('Template deleted successfully!', 'success');
                    }

                    // Reload templates
                    if (typeof window.loadTemplatesData === 'function') {
                        await window.loadTemplatesData();
                    }

                } catch (error) {
                    console.error('Error deleting template:', error);
                    alert('Error deleting template: ' + error.message);
                }
            }
        });

        // Preview template
        document.addEventListener('click', async function(e) {
            if (e.target.closest('[data-action="preview-template"]')) {
                e.preventDefault();
                const button = e.target.closest('[data-action="preview-template"]');
                const templateId = button.getAttribute('data-template-id');

                try {
                    const response = await makeApiCall(`/api/templates/${templateId}`);
                    
                    if (response.success && response.data) {
                        const template = response.data;
                        
                        document.getElementById('preview-template-name').textContent = template.name;
                        document.getElementById('preview-template-content').textContent = template.content;
                        document.getElementById('preview-template-category').textContent = template.category.toUpperCase();
                        
                        // Create variable inputs
                        const variablesForm = document.getElementById('preview-variables-form');
                        if (template.variables && template.variables.length > 0) {
                            variablesForm.innerHTML = template.variables.map(v => `
                                <div class="mb-2">
                                    <label class="form-label small">${v}</label>
                                    <input type="text" class="form-control form-control-sm" 
                                           data-variable="${v}" placeholder="Enter ${v}">
                                </div>
                            `).join('');
                            
                            // Update preview on input
                            variablesForm.addEventListener('input', function() {
                                let previewContent = template.content;
                                template.variables.forEach(v => {
                                    const input = variablesForm.querySelector(`[data-variable="${v}"]`);
                                    if (input && input.value) {
                                        const regex = new RegExp(`\\{\\{${v}\\}\\}`, 'g');
                                        previewContent = previewContent.replace(regex, input.value);
                                    }
                                });
                                document.getElementById('preview-result').textContent = previewContent;
                            });
                            
                            document.getElementById('preview-result').textContent = template.content;
                        } else {
                            variablesForm.innerHTML = '<p class="text-muted small">No variables in this template</p>';
                            document.getElementById('preview-result').textContent = template.content;
                        }
                        
                        const modal = new bootstrap.Modal(document.getElementById('previewTemplateModal'));
                        modal.show();
                    }
                } catch (error) {
                    console.error('Error loading template preview:', error);
                    alert('Error loading template preview: ' + error.message);
                }
            }
        });

        // Auto-refresh dashboard stats every 30 seconds (only if user is logged in and on overview)
        setInterval(async function () {
            const isLoggedIn = sessionStorage.getItem('isLoggedIn') === 'true';
            if (isLoggedIn) {
                // Only refresh data for the currently active section
                const activeSection = document.querySelector('.sidebar-nav .nav-link.active')?.getAttribute('data-section');
                if (activeSection === 'overview') {
                    await loadDashboardData();
                    // Restore API key visibility state after refresh
                    if (isApiKeyVisible) {
                        const apiKeyInput = document.getElementById('api-key');
                        const apiKeyIcon = document.getElementById('api-key-icon');
                        if (apiKeyInput && apiKeyIcon) {
                            apiKeyInput.type = 'text';
                            apiKeyIcon.className = 'fas fa-eye-slash';
                        }
                    }
                }
            }
        }, 30000);

        // Profile form submission
        document.getElementById('profile-form')?.addEventListener('submit', async function (e) {
            e.preventDefault();

            try {
                const formData = new FormData(this);
                const profileData = {
                    name: formData.get('name'),
                    email: formData.get('email'),
                    phone: formData.get('phone'),
                    company: formData.get('company'),
                    bio: formData.get('bio')
                };

                const response = await makeApiCall('/api/auth/profile', {
                    method: 'PUT',
                    body: JSON.stringify(profileData)
                });

                showToast('Profile updated successfully!', 'success');
                await loadProfileData(); // Refresh the profile data
            } catch (error) {
                showToast('Error updating profile: ' + error.message, 'error');
            }
        });

        // Password form submission
        document.getElementById('password-form')?.addEventListener('submit', async function (e) {
            e.preventDefault();

            const newPassword = document.getElementById('new-password').value;
            const confirmPassword = document.getElementById('confirm-password').value;

            if (newPassword !== confirmPassword) {
                alert('New passwords do not match!');
                return;
            }

            if (newPassword.length < 6) {
                alert('Password must be at least 6 characters long!');
                return;
            }

            try {
                const formData = new FormData(this);
                const passwordData = {
                    currentPassword: formData.get('currentPassword'),
                    newPassword: newPassword
                };

                const response = await makeApiCall('/api/auth/change-password', {
                    method: 'POST',
                    body: JSON.stringify(passwordData)
                });

                showToast('Password changed successfully!', 'success');
                this.reset();
            } catch (error) {
                showToast('Error changing password: ' + error.message, 'error');
            }
        });

        // Email verification button
        document.getElementById('verify-email-btn')?.addEventListener('click', async function () {
            try {
                const response = await makeApiCall('/api/auth/send-verification-email', {
                    method: 'POST'
                });

                // Show verification modal
                const modal = new bootstrap.Modal(document.getElementById('emailVerificationModal'));
                document.getElementById('verification-email').textContent = document.getElementById('profile-email').value;

                // Reset modal content first
                const modalBody = document.querySelector('#emailVerificationModal .modal-body');
                modalBody.innerHTML = `
                        <p>We've sent a verification email to <strong id="verification-email"></strong></p>
                        <p>Please check your inbox and click the verification link to verify your email address.</p>
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            If you don't see the email, please check your spam folder.
                        </div>
                    `;
                document.getElementById('verification-email').textContent = document.getElementById('profile-email').value;

                // If verification token is provided (development mode), show it
                if (response.verificationToken) {
                    const modalBody = document.querySelector('#emailVerificationModal .modal-body');
                    modalBody.innerHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                <strong>Email service not configured!</strong>
                            </div>
                            <p>To enable email verification, please configure SMTP settings in your environment variables:</p>
                            <div class="alert alert-info">
                                <strong>Required Environment Variables:</strong><br>
                                <code>SMTP_HOST=smtp.gmail.com</code><br>
                                <code>SMTP_PORT=587</code><br>
                                <code>SMTP_USER=your-email@gmail.com</code><br>
                                <code>SMTP_PASS=your-app-password</code><br>
                                <code>FROM_EMAIL=your-email@gmail.com</code>
                            </div>
                            <p><strong>For now, use this verification link:</strong></p>
                            <div class="alert alert-success">
                                <a href="${response.verificationUrl}" target="_blank" class="btn btn-success">
                                    <i class="fas fa-external-link-alt me-2"></i>Verify Email Now
                                </a>
                            </div>
                        `;
                }

                modal.show();
            } catch (error) {
                alert('Error sending verification email: ' + error.message);
            }
        });

        // Resend verification email
        document.getElementById('resend-verification-btn')?.addEventListener('click', async function () {
            try {
                const response = await makeApiCall('/api/auth/send-verification-email', {
                    method: 'POST'
                });

                alert('Verification email sent!');
            } catch (error) {
                alert('Error resending verification email: ' + error.message);
            }
        });

        // Reset profile form
        document.getElementById('reset-profile-btn')?.addEventListener('click', function () {
            if (confirm('Are you sure you want to reset the form? All changes will be lost.')) {
                loadProfileData();
            }
        });

        // Refresh profile button
        document.getElementById('refresh-profile-btn')?.addEventListener('click', function () {
            loadProfileData();
        });

        // QR code retry button handler - use event delegation
        document.addEventListener('click', function(e) {
            if (e.target.closest('[data-action="retry-qr"]')) {
                e.preventDefault();
                const button = e.target.closest('[data-action="retry-qr"]');
                const sessionId = button.getAttribute('data-session-id');
                if (sessionId && window.startQRCodeGeneration) {
                    window.startQRCodeGeneration(sessionId);
                }
            }
        });
    });

    // Global variable to track API key visibility state
    let isApiKeyVisible = false;

    // Ensure API key buttons are present when user has an API key
    function ensureApiKeyButtons() {
        const apiKeyInput = document.getElementById('api-key');
        const inputGroup = apiKeyInput?.parentElement;
        
        if (!inputGroup) return;
        
        // Check if regenerate button already exists
        if (document.getElementById('regenerate-api-key')) {
            return; // Buttons already exist
        }
        
        // Remove generate button if it exists
        const generateBtn = document.getElementById('generate-api-key');
        if (generateBtn) {
            generateBtn.remove();
        }
        
        // Add the API key management buttons
        const buttonsHTML = `
            <button class="btn btn-outline-secondary" type="button" id="toggle-api-key">
                <i class="fas fa-eye" id="api-key-icon"></i>
            </button>
            <button class="btn btn-outline-secondary" type="button" id="copy-api-key">
                <i class="fas fa-copy"></i>
            </button>
            <button class="btn btn-warning" type="button" id="regenerate-api-key" 
                    data-bs-toggle="tooltip" 
                    data-bs-placement="top" 
                    title="Generate a new API key (this will invalidate the current key)">
                <i class="fas fa-sync-alt"></i>
            </button>
        `;
        
        // Add buttons to the input group
        inputGroup.insertAdjacentHTML('beforeend', buttonsHTML);
        
        console.log('API key buttons added dynamically');
    }

    // Initialize API key buttons function
    function initializeApiKeyButtons() {
        console.log('initializeApiKeyButtons() called');
        
        // Check if user has an API key and ensure buttons are present
        const apiKeyInput = document.getElementById('api-key');
        if (apiKeyInput && apiKeyInput.value && apiKeyInput.value !== 'Not generated') {
            // User has an API key, make sure all buttons are present
            ensureApiKeyButtons();
        }
        
        // Toggle API key visibility
        const toggleBtn = document.getElementById('toggle-api-key');
        const apiKeyIcon = document.getElementById('api-key-icon');

        if (toggleBtn && apiKeyInput && apiKeyIcon) {
            // Remove existing event listeners to prevent duplicates
            const newToggleBtn = toggleBtn.cloneNode(true);
            toggleBtn.parentNode.replaceChild(newToggleBtn, toggleBtn);

            // Restore previous state if any
            if (isApiKeyVisible) {
                    apiKeyInput.type = 'text';
                    apiKeyIcon.className = 'fas fa-eye-slash';
            }

            newToggleBtn.addEventListener('click', function () {
                // Get fresh references to the input and icon elements
                const currentApiKeyInput = document.getElementById('api-key');
                const currentApiKeyIcon = document.getElementById('api-key-icon');
                
                if (isApiKeyVisible) {
                    // Hide the API key
                    currentApiKeyInput.type = 'password';
                    currentApiKeyIcon.className = 'fas fa-eye';
                    isApiKeyVisible = false;
                } else {
                    // Show the API key
                    currentApiKeyInput.type = 'text';
                    currentApiKeyIcon.className = 'fas fa-eye-slash';
                    isApiKeyVisible = true;
                }
            });
        }

        // Copy API key functionality
        const copyBtn = document.getElementById('copy-api-key');
        if (copyBtn && apiKeyInput) {
            // Remove existing event listeners to prevent duplicates
            const newCopyBtn = copyBtn.cloneNode(true);
            copyBtn.parentNode.replaceChild(newCopyBtn, copyBtn);

            newCopyBtn.addEventListener('click', function () {
                // Get fresh reference to the input element
                const currentApiKeyInput = document.getElementById('api-key');
                const apiKey = currentApiKeyInput.value;
                if (apiKey && apiKey !== 'Not generated') {
                    navigator.clipboard.writeText(apiKey).then(function () {
                        // Show success message
                        const originalHTML = newCopyBtn.innerHTML;
                        newCopyBtn.innerHTML = '<i class="fas fa-check"></i>';
                        newCopyBtn.classList.remove('btn-outline-secondary');
                        newCopyBtn.classList.add('btn-success');

                        setTimeout(function () {
                            newCopyBtn.innerHTML = originalHTML;
                            newCopyBtn.classList.remove('btn-success');
                            newCopyBtn.classList.add('btn-outline-secondary');
                        }, 2000);
                    }).catch(function () {
                        alert('Failed to copy API key to clipboard');
                    });
                } else {
                    alert('No API key to copy');
                }
            });
        }

        // Regenerate API key functionality
        const regenerateBtn = document.getElementById('regenerate-api-key');
        console.log('Regenerate button found:', !!regenerateBtn);
        if (regenerateBtn) {
            // Remove existing event listeners to prevent duplicates
            const newRegenerateBtn = regenerateBtn.cloneNode(true);
            regenerateBtn.parentNode.replaceChild(newRegenerateBtn, regenerateBtn);

            newRegenerateBtn.addEventListener('click', async function () {
                // Show confirmation dialog
                if (!confirm('Are you sure you want to regenerate your API key? This will invalidate your current key and any applications using it will need to be updated.')) {
                    return;
                }

                try {
                    // Show loading state
                    const originalContent = this.innerHTML;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    this.disabled = true;
                    this.classList.add('disabled');

                    const data = await makeApiCall('/api/auth/regenerate-api-key', {
                        method: 'POST'
                    });

                    // Get reference to the API key input field
                    const currentApiKeyInput = document.getElementById('api-key');

                    // Update the input field - handle different response structures
                    const apiKey = data?.apiKey || data.apiKey || data.data?.data?.apiKey;
                    if (apiKey && currentApiKeyInput) {
                        currentApiKeyInput.value = apiKey;

                        // Update currentUser object with new API key
                        if (window.currentUser) {
                            window.currentUser.apiKey = apiKey;
                            console.log('Updated window.currentUser.apiKey:', apiKey);
                        }
                        
                        // Also update sessionStorage
                        const storedUser = sessionStorage.getItem('currentUser');
                        if (storedUser) {
                            try {
                                const userObj = JSON.parse(storedUser);
                                userObj.apiKey = apiKey;
                                sessionStorage.setItem('currentUser', JSON.stringify(userObj));
                                console.log('Updated sessionStorage currentUser with new API key');
                            } catch (e) {
                                console.error('Error updating sessionStorage user:', e);
                            }
                        }

                        // Reload sessions if loadSessions function exists
                        if (typeof loadSessions === 'function') {
                            loadSessions();
                        }
                        
                        // Also call the global refresh function if available
                        if (typeof window.refreshSessions === 'function') {
                            window.refreshSessions();
                        }
                        
                        // If we're currently on the sessions page, reload it
                        const currentSection = document.querySelector('.sidebar-nav .nav-link.active')?.getAttribute('data-section');
                        if (currentSection === 'sessions') {
                            setTimeout(() => {
                                loadSectionPage('sessions');
                            }, 500);
                        }

                        // Reload API key data to ensure UI is in sync
                        await loadApiKeyData();

                        // Show success message
                        alert('API key regenerated successfully! Please update any applications using the old key.');
                    } else if (!apiKey) {
                        throw new Error('API key not found in response');
                    } else {
                        throw new Error('API key input field not found');
                    }

                } catch (error) {
                    console.error('Error regenerating API key:', error);
                    
                    // Reset button state
                    this.innerHTML = originalContent;
                    this.disabled = false;
                    this.classList.remove('disabled');
                    
                    alert('Error regenerating API key: ' + error.message);
                }
            });
        }
    }

    // Initialize Session Buttons function
    function initializeSessionButtons() {
        console.log('initializeSessionButtons() called');
        
        // Create new session button
        const createSessionBtn = document.getElementById('create-session-btn');
        if (createSessionBtn) {
            // Remove existing event listeners to prevent duplicates
            const newCreateSessionBtn = createSessionBtn.cloneNode(true);
            createSessionBtn.parentNode.replaceChild(newCreateSessionBtn, createSessionBtn);

            newCreateSessionBtn.addEventListener('click', async function () {
                let originalContent = this.innerHTML;
                
                try {
                    // Check if API key exists first
                    const apiKey = getApiKey();
                    if (!apiKey) {
                        alert('Please generate an API key first!\n\n1. Go to the Overview section\n2. Click "Generate API Key"\n3. Then return here to create sessions');
                        
                        // Redirect to overview section
                        const overviewLink = document.querySelector('[data-section="overview"]');
                        if (overviewLink) {
                            overviewLink.click();
                        }
                        return;
                    }

                    // Show loading state
                    originalContent = this.innerHTML;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Creating Session...';
                    this.disabled = true;
                    this.classList.add('disabled');

                    const response = await makeApiCall('/api/whatsapp/sessions', {
                        method: 'POST',
                        body: JSON.stringify({
                            name: 'Session ' + new Date().toLocaleString(),
                            settings: {
                                autoReply: false,
                                allowGroups: true,
                                allowUnknown: true
                            }
                        })
                    });

                    // Reset button state
                    this.innerHTML = originalContent;
                    this.disabled = false;
                    this.classList.remove('disabled');

                    // Show QR code modal for the new session
                    if (response.session && response.session.sessionId) {
                        showQRCodeModal(response.session.sessionId);
                        // Wait a moment for modal to fully render, then start QR code generation
                        setTimeout(async () => {
                            await startQRCodeGeneration(response.session.sessionId);
                        }, 100);
                        // Refresh sessions data after showing QR code
                        setTimeout(() => {
                            loadSessionsData();
                            // Also refresh overview stats
                            if (typeof loadSessions === 'function') {
                                loadSessions();
                            }
                        }, 1000);
                    } else {
                        showToast('Session created successfully!', 'success');
                        // Refresh sessions data instead of reloading page
                        loadSessionsData();
                        // Also refresh overview stats
                        if (typeof loadSessions === 'function') {
                            loadSessions();
                        }
                    }
                } catch (error) {
                    console.error('Error creating session:', error);
                    
                    // Reset button state on error
                    this.innerHTML = originalContent;
                    this.disabled = false;
                    this.classList.remove('disabled');
                    
                    // Show user-friendly error message
                    if (error.message.includes('Maximum sessions reached')) {
                        alert('You have reached the maximum number of sessions for your plan. Please delete an existing session or upgrade your plan.');
                    } else {
                        alert('Error creating session: ' + error.message);
                    }
                }
            });
        }

        // Refresh sessions page button
        const refreshSessionsPageBtn = document.getElementById('refresh-sessions-page-btn');
        if (refreshSessionsPageBtn) {
            const newRefreshBtn = refreshSessionsPageBtn.cloneNode(true);
            refreshSessionsPageBtn.parentNode.replaceChild(newRefreshBtn, refreshSessionsPageBtn);

            newRefreshBtn.addEventListener('click', async function () {
                const originalContent = this.innerHTML;
                
                try {
                    // Show loading state
                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Refreshing...';
                    this.disabled = true;
                    this.classList.add('disabled');

                    // Reload the sessions section page
                    if (typeof loadSectionPage === 'function') {
                        await loadSectionPage('sessions');
                    }

                    // Also refresh sessions data
                    if (typeof window.loadSessionsData === 'function') {
                        await window.loadSessionsData();
                    }

                    // Show success feedback
                    this.innerHTML = '<i class="fas fa-check me-1"></i>Refreshed';
                    this.classList.remove('btn-outline-secondary');
                    this.classList.add('btn-success');

                    // Show toast notification
                    if (typeof showToast === 'function') {
                        showToast('Sessions refreshed successfully!', 'success');
                    }

                    // Reset button after delay
                    setTimeout(() => {
                        this.innerHTML = originalContent;
                        this.classList.remove('btn-success');
                        this.classList.add('btn-outline-secondary');
                        this.disabled = false;
                        this.classList.remove('disabled');
                    }, 1500);

                } catch (error) {
                    console.error('Error refreshing sessions:', error);
                    this.innerHTML = originalContent;
                    this.disabled = false;
                    this.classList.remove('disabled');
                    alert('Error refreshing sessions: ' + error.message);
                }
            });
        }

        // Create first session button
        const createFirstSessionBtn = document.getElementById('create-first-session-btn');
        if (createFirstSessionBtn) {
            // Remove existing event listeners to prevent duplicates
            const newCreateFirstSessionBtn = createFirstSessionBtn.cloneNode(true);
            createFirstSessionBtn.parentNode.replaceChild(newCreateFirstSessionBtn, createFirstSessionBtn);

            newCreateFirstSessionBtn.addEventListener('click', async function () {
                let originalContent = this.innerHTML;
                
                try {
                    // Check if API key exists first
                    const apiKey = getApiKey();
                    if (!apiKey) {
                        alert('Please generate an API key first!\n\n1. Go to the Overview section\n2. Click "Generate API Key"\n3. Then return here to create sessions');
                        
                        // Redirect to overview section
                        const overviewLink = document.querySelector('[data-section="overview"]');
                        if (overviewLink) {
                            overviewLink.click();
                        }
                        return;
                    }

                    // Show loading state
                    originalContent = this.innerHTML;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Creating Session...';
                    this.disabled = true;
                    this.classList.add('disabled');

                    const response = await makeApiCall('/api/whatsapp/sessions', {
                        method: 'POST',
                        body: JSON.stringify({
                            name: 'Session ' + new Date().toLocaleString(),
                            settings: {
                                autoReply: false,
                                allowGroups: true,
                                allowUnknown: true
                            }
                        })
                    });

                    // Reset button state
                    this.innerHTML = originalContent;
                    this.disabled = false;
                    this.classList.remove('disabled');

                    // Show QR code modal for the new session
                    if (response.session && response.session.sessionId) {
                        showQRCodeModal(response.session.sessionId);
                        // Wait a moment for modal to fully render, then start QR code generation
                        setTimeout(async () => {
                            await startQRCodeGeneration(response.session.sessionId);
                        }, 100);
                        // Refresh sessions data after showing QR code
                        setTimeout(() => {
                            loadSessionsData();
                            // Also refresh overview stats
                            if (typeof loadSessions === 'function') {
                                loadSessions();
                            }
                        }, 1000);
                    } else {
                        showToast('Session created successfully!', 'success');
                        // Refresh sessions data instead of reloading page
                        loadSessionsData();
                        // Also refresh overview stats
                        if (typeof loadSessions === 'function') {
                            loadSessions();
                        }
                    }
                } catch (error) {
                    console.error('Error creating session:', error);
                    
                    // Reset button state on error
                    this.innerHTML = originalContent;
                    this.disabled = false;
                    this.classList.remove('disabled');
                    
                    // Show user-friendly error message
                    if (error.message.includes('Maximum sessions reached')) {
                        alert('You have reached the maximum number of sessions for your plan. Please delete an existing session or upgrade your plan.');
                    } else {
                        alert('Error creating session: ' + error.message);
                    }
                }
            });
        }

        // Add event listeners for dynamically created session buttons
        // Connect session buttons - Clone buttons to prevent duplicate event listeners
        document.querySelectorAll('.connect-session-btn').forEach(btn => {
            // Remove existing event listeners by cloning the button
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', async function() {
                const sessionId = this.getAttribute('data-session-id');
                const originalContent = this.innerHTML;
                
                try {
                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Connecting...';
                    this.disabled = true;
                    
                    const response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}/connect`, {
                        method: 'POST'
                    });
                    
                    if (response.success) {
                        // Show QR code modal
                        showQRCodeModal(sessionId);
                        setTimeout(async () => {
                            await startQRCodeGeneration(sessionId);
                        }, 100);
                        
                        // Refresh sessions data
                        setTimeout(() => {
                            loadSessionsData();
                        }, 1000);
                    } else {
                        alert('Failed to connect session: ' + (response.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error connecting session:', error);
                    showToast('Error connecting session: ' + error.message, 'error');
                } finally {
                    this.innerHTML = originalContent;
                    this.disabled = false;
                }
            });
        });

        // Disconnect session buttons - Clone buttons to prevent duplicate event listeners
        document.querySelectorAll('.disconnect-session-btn').forEach(btn => {
            // Remove existing event listeners by cloning the button
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', async function() {
                const sessionId = this.getAttribute('data-session-id');
                const originalContent = this.innerHTML;
                
                if (!confirm('Are you sure you want to disconnect this session?')) {
                    return;
                }
                
                try {
                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Disconnecting...';
                    this.disabled = true;
                    
                    const response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}/disconnect`, {
                        method: 'POST'
                    });
                    
                    if (response.success) {
                        showToast('Session disconnected successfully!', 'success');
                        // Refresh sessions data
                        loadSessionsData();
                    } else {
                        alert('Failed to disconnect session: ' + (response.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error disconnecting session:', error);
                    showToast('Error disconnecting session: ' + error.message, 'error');
                } finally {
                    this.innerHTML = originalContent;
                    this.disabled = false;
                }
            });
        });

        // Delete session buttons - Clone buttons to prevent duplicate event listeners
        document.querySelectorAll('.delete-session-btn').forEach(btn => {
            // Remove existing event listeners by cloning the button
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', async function() {
                const sessionId = this.getAttribute('data-session-id');
                const originalContent = this.innerHTML;
                
                if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                    return;
                }
                
                try {
                    this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Deleting...';
                    this.disabled = true;
                    
                    const response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.success) {
                        showToast('Session deleted successfully!', 'success');
                        // Refresh sessions data
                        loadSessionsData();
                    } else {
                        alert('Failed to delete session: ' + (response.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error deleting session:', error);
                    alert('Error deleting session: ' + error.message);
                } finally {
                    this.innerHTML = originalContent;
                    this.disabled = false;
                }
            });
        });
    }

    // QR Code Modal Functions - Updated for better connection detection
    let currentSessionId = null;

    function showQRCodeModal(sessionId) {
        currentSessionId = sessionId;
        
        // Clean up any existing backdrops before showing modal
        if (window.cleanupModalBackdrops) {
            window.cleanupModalBackdrops();
        }
        
        const modalElement = document.getElementById('qrCodeModal');
        console.log('Modal element found:', !!modalElement);
        
        // Reset modal title to show connecting state
        const modalTitle = document.querySelector('#qrCodeModal .modal-title');
        if (modalTitle) {
            modalTitle.innerHTML = `
                <i class="fab fa-whatsapp me-2"></i>Connect WhatsApp Session
                <span class="badge bg-warning ms-2">Connecting...</span>
            `;
            console.log('Modal title updated');
        }

        // Reset modal content to show initial loading state with progress
        const container = document.getElementById('qr-code-container');
        if (container) {
            container.innerHTML = `
                <div class="text-center">
                    <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Connecting...</span>
                    </div>
                    <p class="text-muted">Connecting to WhatsApp...</p>
                    <p class="text-muted small">This may take up to 5 minutes</p>
                    <div class="progress mt-3" style="height: 8px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated bg-warning" 
                             role="progressbar" 
                             style="width: 0%" 
                             id="qr-progress-bar"></div>
                    </div>
                    <p class="text-muted small mt-2" id="qr-progress-text">Initializing connection...</p>
                    <p class="text-info small" id="qr-status-text">
                        <i class="fas fa-info-circle me-1"></i>
                        Starting WhatsApp session...
                    </p>
                </div>
            `;
        } else {
            console.error('QR container not found!');
        }

        // Show modal
        const modal = new bootstrap.Modal(modalElement);
        modal.show();
        
        // Force a re-render by updating the container again after modal is shown
        setTimeout(() => {
            const container = document.getElementById('qr-code-container');
            if (container) {
                container.innerHTML = `
                    <div class="text-center">
                        <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                            <span class="visually-hidden">Connecting...</span>
                        </div>
                        <p class="text-muted">Connecting to WhatsApp...</p>
                        <p class="text-muted small">This may take up to 5 minutes</p>
                        <div class="progress mt-3" style="height: 8px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated bg-warning" 
                                 role="progressbar" 
                                 style="width: 0%" 
                                 id="qr-progress-bar"></div>
                        </div>
                        <p class="text-muted small mt-2" id="qr-progress-text">Initializing connection...</p>
                        <p class="text-info small" id="qr-status-text">
                            <i class="fas fa-info-circle me-1"></i>
                            Starting WhatsApp session...
                        </p>
                    </div>
                `;
            }
        }, 50);
        
        // Note: QR code generation will be handled by startQRCodeGeneration()
        // which will be called after this function returns
    }

    async function startQRCodeGeneration(sessionId) {
        
        // Update modal title to show generation in progress
        const modalTitle = document.querySelector('#qrCodeModal .modal-title');
        if (modalTitle) {
            modalTitle.innerHTML = `
                <i class="fab fa-whatsapp me-2"></i>Connect WhatsApp Session
                <span class="badge bg-info ms-2">Starting...</span>
            `;
        }
        
        // Update modal content to show generation in progress
        const container = document.getElementById('qr-code-container');
        if (container) {
            container.innerHTML = `
                <div class="text-center">
                    <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Starting QR Generation...</span>
                    </div>
                    <p class="text-muted">Initializing WhatsApp session...</p>
                    <p class="text-muted small">Please wait while we prepare your QR code</p>
                    <div class="progress mt-3" style="height: 8px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated bg-info" 
                             role="progressbar" 
                             style="width: 10%" 
                             id="qr-progress-bar"></div>
                    </div>
                    <p class="text-muted small mt-2" id="qr-status-text">
                        <i class="fas fa-cog fa-spin me-1"></i>
                        Initializing session...
                    </p>
                </div>
            `;
            
            // Poll for QR code status - faster polling for better responsiveness
            const maxAttempts = 120; // 2 minutes with 1-second intervals
            const pollInterval = 1000; // 1 second for faster updates
            let attempts = 0;

            const pollForQRCode = async () => {
                try {
                    attempts++;
                    console.log(`QR polling attempt ${attempts}/${maxAttempts} for session ${sessionId}`);

                    // Use new status endpoint for better real-time updates
                    const response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}/qr/status`);

                if (response.success) {
                    const { status, qrCode, message } = response;
                    
                    // Update progress based on status
                    updateQRProgress(status, attempts, maxAttempts, message);

                    switch (status) {
                        case 'ready':
                            if (qrCode) {
                                console.log('QR code is ready, displaying...');
                                await displayQRCode(sessionId, { success: true, qrCode, status: 'ready' });
                                // Don't stop polling - continue to detect when user scans
                                if (attempts < maxAttempts) {
                                    setTimeout(pollForQRCode, 3000); // Continue polling to detect scan
                                }
                                return;
                            }
                            break;
                            
                        case 'connected':
                            console.log('Session connected, closing modal...');
                            
                            // Update the modal content to show success
                            const container = document.getElementById('qr-code-container');
                            if (container) {
                                container.innerHTML = `
                                    <div class="text-center">
                                        <div class="mb-3">
                                            <i class="fas fa-check-circle text-success" style="font-size: 4rem;"></i>
                                        </div>
                                        <h4 class="text-success mb-3">Connected Successfully!</h4>
                                        <p class="text-muted">Your WhatsApp session is now active and ready to use.</p>
                                        <p class="small text-muted">This window will close automatically...</p>
                                    </div>
                                `;
                            }
                            
                            // Update modal title
                            const modalTitle = document.querySelector('#qrCodeModal .modal-title');
                            if (modalTitle) {
                                modalTitle.innerHTML = `
                                    <i class="fas fa-check-circle me-2 text-success"></i>WhatsApp Connected
                                `;
                            }
                            
                            // Close modal after a short delay
                            setTimeout(() => {
                                const modal = bootstrap.Modal.getInstance(document.getElementById('qrCodeModal'));
                                if (modal) {
                                    modal.hide();
                                    // Show success toast after modal closes
                                    setTimeout(() => {
                                        showSuccessMessage('WhatsApp session connected successfully!');
                                    }, 300);
                                }
                            }, 2000);
                            
                            // Get current active section before refreshing
                            const activeSection = document.querySelector('.sidebar-nav .nav-link.active')?.getAttribute('data-section');
                            
                            // Refresh sessions data immediately
                            if (typeof window.loadSessionsData === 'function') {
                                window.loadSessionsData();
                            }
                            
                            // Reload the current section page to show updated data
                            setTimeout(() => {
                                if (typeof loadSectionPage === 'function') {
                                    console.log(`Reloading section after connection: ${activeSection}`);
                                    loadSectionPage(activeSection || 'overview');
                                }
                            }, 1000);
                            
                            // Refresh overview session dropdowns if on overview
                            if (activeSection === 'overview' && typeof loadOverviewSessionDropdowns === 'function') {
                                setTimeout(() => {
                                    loadOverviewSessionDropdowns();
                                }, 1500);
                            }
                            
                            // Final refresh to ensure everything is synced
                            setTimeout(() => {
                                if (typeof window.loadSessionsData === 'function') {
                                    window.loadSessionsData();
                                }
                                // Reload section again to be absolutely sure
                                if (typeof loadSectionPage === 'function') {
                                    console.log(`Final section reload: ${activeSection}`);
                                    loadSectionPage(activeSection || 'overview');
                                }
                            }, 3000);
                            
                            return;
                            
                        case 'error':
                            throw new Error(response.error || 'QR code generation failed');
                            
                        case 'expired':
                            throw new Error('QR code has expired. Please try again.');
                            
                        case 'not_found':
                            // Session not found in manager, try to restart
                            console.log('QR session not found, restarting...');
                            const initResponse = await makeApiCall(`/api/whatsapp/sessions/${sessionId}/qr`);
                            if (!initResponse.success) {
                                throw new Error(initResponse.error || 'Failed to restart QR generation');
                            }
                            break;
                            
                        case 'initializing':
                        case 'generating':
                        default:
                            // Continue polling
                            if (attempts < maxAttempts) {
                                setTimeout(pollForQRCode, 3000); // Poll every 3 seconds
                            } else {
                                throw new Error('QR code generation timeout after 90 seconds');
                            }
                            break;
                    }
                } else {
                    throw new Error(response.error || 'Failed to get QR status');
                }
            } catch (error) {
                console.error('Error polling for QR code:', error);
                
                // Reset browser tab title
                document.title = document.title.replace(/^\[.*?\]\s*/, '');
                
                // Show error in modal
                const container = document.getElementById('qr-code-container');
                if (container) {
                    container.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            <strong>Error:</strong> ${error.message}
                            <div class="mt-2">
                                <button class="btn btn-outline-primary btn-sm" data-action="retry-qr" data-session-id="${sessionId}">
                                    <i class="fas fa-redo me-1"></i>Try Again
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                // Update modal title
                const modalTitle = document.querySelector('#qrCodeModal .modal-title');
                if (modalTitle) {
                    modalTitle.innerHTML = `
                        <i class="fab fa-whatsapp me-2"></i>Connect WhatsApp Session
                        <span class="badge bg-danger ms-2">Error</span>
                    `;
                }
            }
        };

        // Start polling
        pollForQRCode();
    }

    // New function to update progress based on status
    function updateQRProgress(status, attempts, maxAttempts, message) {
        const progressBar = document.getElementById('qr-progress-bar');
        const statusText = document.getElementById('qr-status-text');
        const modalTitle = document.querySelector('#qrCodeModal .modal-title');
        
        let progress = 0;
        let progressColor = 'bg-info';
        let badgeText = 'Processing';
        let badgeColor = 'bg-info';
        let icon = 'fas fa-cog fa-spin';
        
        switch (status) {
            case 'initializing':
                progress = 20;
                progressColor = 'bg-info';
                badgeText = 'Initializing';
                icon = 'fas fa-cog fa-spin';
                break;
            case 'generating':
                progress = 60;
                progressColor = 'bg-warning';
                badgeText = 'Generating';
                badgeColor = 'bg-warning';
                icon = 'fas fa-qrcode';
                break;
            case 'ready':
                progress = 100;
                progressColor = 'bg-success';
                badgeText = 'Ready';
                badgeColor = 'bg-success';
                icon = 'fas fa-check';
                break;
            case 'error':
                progress = 100;
                progressColor = 'bg-danger';
                badgeText = 'Error';
                badgeColor = 'bg-danger';
                icon = 'fas fa-exclamation-triangle';
                break;
            default:
                progress = Math.min((attempts / maxAttempts) * 80, 80);
        }
        
        if (progressBar) {
            progressBar.style.width = `${progress}%`;
            progressBar.className = `progress-bar progress-bar-striped progress-bar-animated ${progressColor}`;
        }
        
        if (statusText) {
            statusText.innerHTML = `
                <i class="${icon} me-1"></i>
                ${message || 'Processing...'}
            `;
        }
        
        if (modalTitle) {
            modalTitle.innerHTML = `
                <i class="fab fa-whatsapp me-2"></i>Connect WhatsApp Session
                <span class="badge ${badgeColor} ms-2">${badgeText}</span>
            `;
        }
        
        // Update browser tab title
        const originalTitle = document.title.replace(/^\[.*?\]\s*/, '');
        document.title = `[${badgeText}] ${originalTitle}`;
    }

    async function displayQRCode(sessionId, qrCodeData) {
        try {
            const container = document.getElementById('qr-code-container');
            if (!container) {
                console.error('QR code container not found');
                return;
            }
            
            // Reset browser tab title
            document.title = document.title.replace(/^\[.*?\]\s*/, '');
            
            // Reset modal title to success state
            const modalTitle = document.querySelector('#qrCodeModal .modal-title');
            if (modalTitle) {
                modalTitle.innerHTML = `
                    <i class="fab fa-whatsapp me-2"></i>Connect WhatsApp Session
                    <span class="badge bg-success ms-2">Ready to Scan</span>
                `;
            }
            
            // Ensure QR code has proper data URL format
            const qrCodeSrc = qrCodeData.qrCode.startsWith('data:image') 
                ? qrCodeData.qrCode 
                : `data:image/png;base64,${qrCodeData.qrCode}`;
            
            container.innerHTML = `
                <div class="text-center">
                    <div class="qr-code-wrapper mb-3">
                        <img src="${qrCodeSrc}" 
                             alt="WhatsApp QR Code" 
                             class="img-fluid border rounded shadow-sm"
                             style="max-width: 280px; background: white; padding: 10px;">
                    </div>
                    <div class="alert alert-success">
                        <i class="fas fa-mobile-alt me-2"></i>
                        <strong>Scan with WhatsApp:</strong>
                        <ol class="text-start mt-2 mb-0">
                            <li>Open WhatsApp on your phone</li>
                            <li>Tap <strong>Settings</strong> → <strong>Linked Devices</strong></li>
                            <li>Tap <strong>Link a Device</strong></li>
                            <li>Scan this QR code</li>
                        </ol>
                    </div>
                    <div class="mt-2">
                        <button class="btn btn-outline-primary btn-sm" data-action="retry-qr" data-session-id="${sessionId}">
                            <i class="fas fa-redo me-1"></i>Refresh QR Code
                        </button>
                    </div>
                </div>
            `;
            
            console.log('QR code displayed successfully');
        } catch (error) {
            console.error('Error displaying QR code:', error);
            const container = document.getElementById('qr-code-container');
            if (container) {
                container.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Error displaying QR code: ${error.message}
                    </div>
                `;
            }
        }
    }
    
    function showSuccessMessage(message) {
        // You can customize this to show toast notifications or other success indicators
        console.log('Success:', message);
        // Example: show a toast notification if you have a toast system
        if (typeof showToast === 'function') {
            showToast(message, 'success');
        } else {
            alert(message);
        }
    }

    // Refresh QR code button
    document.getElementById('refresh-qr-btn')?.addEventListener('click', function () {
        if (currentSessionId) {
            loadQRCode(currentSessionId);
        }
    });

    // Auto-refresh QR code every 2 minutes
    setInterval(() => {
        if (currentSessionId && document.getElementById('qrCodeModal').classList.contains('show')) {
            loadQRCode(currentSessionId);
        }
    }, 120000); // 2 minutes


    // Add keyboard shortcut to clean up backdrops (Ctrl+Shift+B)
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'B') {
            e.preventDefault();
            if (window.cleanupModalBackdrops) {
                window.cleanupModalBackdrops();
                alert('Modal backdrops cleaned up!');
            }
        }
    });

    // Add keyboard shortcut to test modal update (Ctrl+Shift+M)
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'M') {
            e.preventDefault();
            console.log('Testing modal update...');
            const container = document.getElementById('qr-code-container');
            if (container) {
                container.innerHTML = `
                    <div class="text-center">
                        <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
                            <span class="visually-hidden">Testing...</span>
                        </div>
                        <p class="text-muted">Test Modal Update</p>
                        <p class="text-success">Modal content updated successfully!</p>
                    </div>
                `;
                console.log('Modal test update applied');
                alert('Modal test update applied!');
            } else {
                console.error('QR container not found for test');
                alert('QR container not found!');
            }
        }
    });

    // Initialize enhanced dashboard functionality
    initializeEnhancedDashboard();

    function initializeEnhancedDashboard() {
        // Load connected sessions for dropdowns
        loadConnectedSessions();

        // Overview page functionality is now handled by initializeOverviewForms() when section loads

        // Initialize messages page functionality
        initializeMessagesFunctionality();
    }

    async function loadConnectedSessions() {
        try {
            const response = await makeApiCall('/api/whatsapp/sessions');
            if (response.success && response.sessions) {
                const connectedSessions = response.sessions.filter(session => session.status === 'connected');
                updateSessionDropdowns(connectedSessions);
            }
        } catch (error) {
            console.error('Error loading sessions:', error);
        }
    }

    function updateSessionDropdowns(sessions) {
        const dropdowns = [
            'quick-session-select',
            'bulk-session-select', 
            'bot-default-session',
            'compose-session',
            'session-filter'
        ];

        dropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
                // Clear existing options except first
                dropdown.innerHTML = dropdown.firstElementChild.outerHTML;
                
                sessions.forEach(session => {
                    const option = document.createElement('option');
                    option.value = session.sessionId;
                    option.textContent = `${session.phoneNumber || session.sessionId} (${session.status})`;
                    dropdown.appendChild(option);
                });
            }
        });
    }

    // initializeOverviewFunctionality() removed - now handled by initializeOverviewForms() when section loads

    function initializeMessagesFunctionality() {
        // Compose message button
        const composeBtn = document.getElementById('compose-message');
        if (composeBtn) {
            composeBtn.addEventListener('click', () => {
                loadConnectedSessions(); // Refresh sessions before opening modal
            });
        }

        // Send composed message
        const sendBtn = document.getElementById('send-composed-message');
        if (sendBtn) {
            sendBtn.addEventListener('click', sendComposedMessage);
        }

        // Character counter for compose message
        const composeText = document.getElementById('compose-text');
        if (composeText) {
            composeText.addEventListener('input', updateCharCount);
        }

        // Message filters
        const filterInputs = document.querySelectorAll('input[name="message-filter"]');
        filterInputs.forEach(input => {
            input.addEventListener('change', filterMessages);
        });

        // Session filter
        const sessionFilter = document.getElementById('session-filter');
        if (sessionFilter) {
            sessionFilter.addEventListener('change', filterMessages);
        }

        // Search messages
        const searchInput = document.getElementById('message-search');
        if (searchInput) {
            searchInput.addEventListener('input', debounce(searchMessages, 300));
        }

        // Refresh messages
        const refreshBtn = document.getElementById('refresh-messages');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', loadMessagesData);
        }

        // Export messages
        const exportBtn = document.getElementById('export-messages');
        if (exportBtn) {
            exportBtn.addEventListener('click', exportMessages);
        }
    }

    async function sendComposedMessage() {
        const sessionId = document.getElementById('compose-session').value;
        const phone = document.getElementById('compose-phone').value;
        const message = document.getElementById('compose-text').value;
        const mediaFile = document.getElementById('compose-media').files[0];

        if (!sessionId || !phone || !message) {
            alert('Please fill in all required fields');
            return;
        }

        const sendBtn = document.getElementById('send-composed-message');
        const originalText = sendBtn.innerHTML;
        
        try {
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Sending...';
            sendBtn.disabled = true;

            let response;
            
            if (mediaFile) {
                // Send media message
                const formData = new FormData();
                formData.append('to', phone);
                formData.append('caption', message);
                formData.append('media', mediaFile);

                const headers = getApiKeyHeaders();
                delete headers['Content-Type']; // Let browser set content-type for FormData
                
                response = await fetch(`/api/whatsapp/sessions/${sessionId}/media`, {
                    method: 'POST',
                    headers: headers,
                    body: formData
                });
                response = await response.json();
            } else {
                // Send text message
                response = await makeApiCall(`/api/whatsapp/sessions/${sessionId}/messages`, {
                    method: 'POST',
                    body: JSON.stringify({
                        to: phone,
                        message: message
                    })
                });
            }

            if (response.success) {
                showToast('Message sent successfully!', 'success');
                document.getElementById('compose-message-form').reset();
                updateCharCount(); // Reset character count
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('composeMessageModal'));
                if (modal) modal.hide();
                
                loadMessagesData(); // Refresh messages
            } else {
                throw new Error(response.error || 'Failed to send message');
            }
        } catch (error) {
            console.error('Error sending message:', error);
            alert('Error sending message: ' + error.message);
        } finally {
            sendBtn.innerHTML = originalText;
            sendBtn.disabled = false;
        }
    }

    function updateCharCount() {
        const textArea = document.getElementById('compose-text');
        const counter = document.getElementById('char-count');
        if (textArea && counter) {
            counter.textContent = textArea.value.length;
        }
    }

    function downloadCSVTemplate() {
        const csvContent = "phone,message\n+1234567890,Hello! This is a sample message.\n+0987654321,Welcome to our service!";
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'bulk_message_template.csv';
        a.click();
        window.URL.revokeObjectURL(url);
    }

    async function handleBulkUpload() {
        const sessionId = document.getElementById('bulk-session-select').value;
        const csvFile = document.getElementById('bulk-csv').files[0];

        if (!sessionId || !csvFile) {
            alert('Please select a session and CSV file');
            return;
        }

        // TODO: Implement bulk upload functionality
        alert('Bulk upload functionality will be implemented in the next update');
    }

    function saveBotConfiguration() {
        const config = {
            name: document.getElementById('bot-name').value,
            defaultSession: document.getElementById('bot-default-session').value,
            welcomeMessage: document.getElementById('bot-welcome').value,
            fallbackMessage: document.getElementById('bot-fallback').value,
            website: document.getElementById('bot-website').value,
            enabled: document.getElementById('bot-enabled').checked
        };

        // TODO: Save to backend
        console.log('Bot configuration:', config);
        alert('Bot configuration saved! (Backend integration pending)');
    }

    async function testWebhook() {
        try {
            // TODO: Implement webhook testing
            alert('Webhook test functionality will be implemented in the next update');
        } catch (error) {
            alert('Error testing webhook: ' + error.message);
        }
    }

    function exportContacts() {
        // TODO: Implement contact export
        alert('Contact export functionality will be implemented in the next update');
    }

    function backupData() {
        // TODO: Implement data backup
        alert('Data backup functionality will be implemented in the next update');
    }

    function filterMessages() {
        // TODO: Implement message filtering
        console.log('Filtering messages...');
    }

    function searchMessages() {
        // TODO: Implement message search
        console.log('Searching messages...');
    }

    function exportMessages() {
        // TODO: Implement message export
        alert('Message export functionality will be implemented in the next update');
    }

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // End of DOMContentLoaded event listener
};

// Define message loading functions outside DOMContentLoaded so they're globally available
window.loadInlineMessagesData = async function(sessions) {
    console.log('=== LOADING MESSAGES DATA INLINE ===');
    try {
        const messagesTable = document.getElementById('messages-table');
        const messagesEmpty = document.getElementById('messages-empty');
        
        if (!messagesTable) {
            console.error('Messages table not found');
            return;
        }

        // Show loading state
        messagesTable.innerHTML = `
            <tr>
                <td colspan="7" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <div class="mt-2">Loading messages...</div>
                </td>
            </tr>
        `;

        let allMessages = [];
        
        // Get messages from all sessions
        for (const session of sessions) {
            try {
                const sessionId = session.sessionId || session.id;
                console.log(`Loading messages from session: ${sessionId}`);
                
                const response = await window.makeApiCall(`/api/whatsapp/sessions/${sessionId}/messages?page=1&limit=100`);
                
                console.log(`API response for session ${sessionId}:`, response);
                
                let sessionMessages = [];
                if (response && response.success) {
                    // Handle different response formats
                    if (response.messages && Array.isArray(response.messages)) {
                        sessionMessages = response.messages;
                    } else if (response.data && response.data.messages && Array.isArray(response.data.messages)) {
                        sessionMessages = response.data.messages;
                    } else if (Array.isArray(response.data)) {
                        sessionMessages = response.data;
                    }
                    
                    // Add session ID to each message
                    sessionMessages = sessionMessages.map(msg => ({
                        ...msg,
                        sessionId: sessionId
                    }));
                    
                    allMessages = allMessages.concat(sessionMessages);
                    console.log(`Found ${sessionMessages.length} messages from session ${sessionId}`);
                }
            } catch (error) {
                console.warn(`Failed to get messages from session ${session.sessionId || session.id}:`, error);
            }
        }

        console.log('Total messages loaded:', allMessages.length);

        // Sort by creation date (newest first)
        allMessages.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        if (allMessages.length === 0) {
            messagesTable.innerHTML = '';
            if (messagesEmpty) messagesEmpty.style.display = 'block';
        } else {
            if (messagesEmpty) messagesEmpty.style.display = 'none';
            window.renderInlineMessagesTable(allMessages.slice(0, 20)); // Show first 20 messages
        }

    } catch (error) {
        console.error('Error loading messages inline:', error);
        const messagesTable = document.getElementById('messages-table');
        if (messagesTable) {
            messagesTable.innerHTML = `
                <tr>
                    <td colspan="7" class="text-center py-4 text-danger">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Error loading messages: ${error.message}
                    </td>
                </tr>
            `;
        }
    }
};

// Inline messages table renderer
window.renderInlineMessagesTable = function(messages) {
    const messagesTable = document.getElementById('messages-table');
    
    messagesTable.innerHTML = messages.map(message => {
        const messagePreview = message.content ? 
            (message.content.length > 50 ? message.content.substring(0, 50) + '...' : message.content) : 
            `[${message.type}]`;
            
        const statusBadge = window.getInlineStatusBadge(message.status);
        const typeBadge = window.getInlineTypeBadge(message.type);
        const directionIcon = message.direction === 'outbound' ? 
            '<i class="fas fa-arrow-up text-success"></i>' : 
            '<i class="fas fa-arrow-down text-primary"></i>';
            
        const timeFormatted = new Date(message.createdAt).toLocaleString();
        const contact = message.direction === 'outbound' ? message.to : message.from;
        const contactDisplay = contact ? contact.replace('@c.us', '').replace('@g.us', ' (Group)') : 'Unknown';
        
        return `
            <tr>
                <td>
                    <small class="text-muted font-monospace">${message.messageId || 'N/A'}</small>
                </td>
                <td>
                    <small class="text-muted">${message.sessionId || 'Unknown'}</small>
                </td>
                <td>
                    ${directionIcon}
                    <span class="ms-1">${contactDisplay}</span>
                </td>
                <td>
                    <div class="message-preview" title="${message.content || ''}">${messagePreview}</div>
                </td>
                <td>${typeBadge}</td>
                <td>${statusBadge}</td>
                <td>
                    <small class="text-muted">${timeFormatted}</small>
                </td>
            </tr>
        `;
    }).join('');
};

// Inline badge functions
window.getInlineStatusBadge = function(status) {
    const badges = {
        'pending': '<span class="badge bg-warning">Pending</span>',
        'sent': '<span class="badge bg-info">Sent</span>',
        'delivered': '<span class="badge bg-success">Delivered</span>',
        'read': '<span class="badge bg-primary">Read</span>',
        'failed': '<span class="badge bg-danger">Failed</span>'
    };
    return badges[status] || '<span class="badge bg-secondary">Unknown</span>';
};

window.getInlineTypeBadge = function(type) {
    const badges = {
        'text': '<span class="badge bg-light text-dark">Text</span>',
        'chat': '<span class="badge bg-light text-dark">Chat</span>',
        'image': '<span class="badge bg-info">Image</span>',
        'video': '<span class="badge bg-primary">Video</span>',
        'audio': '<span class="badge bg-success">Audio</span>',
        'document': '<span class="badge bg-warning">Document</span>',
        'location': '<span class="badge bg-danger">Location</span>',
        'contact': '<span class="badge bg-secondary">Contact</span>',
        'sticker': '<span class="badge bg-purple">Sticker</span>',
        'gif': '<span class="badge bg-pink">GIF</span>'
    };
    return badges[type] || '<span class="badge bg-secondary">Unknown</span>';
};

// Initialize message page buttons when messages section is loaded
window.initializeMessageButtons = function() {
    console.log('Initializing message page buttons...');
    
    // Compose message button
    setTimeout(() => {
        const composeBtn = document.getElementById('compose-message');
        if (composeBtn) {
            console.log('Found compose button, attaching event listener');
            composeBtn.addEventListener('click', async function(e) {
                e.preventDefault();
                console.log('Compose button clicked');
                
                // Load sessions for compose modal
                await window.loadSessionsForCompose();
                
                // Show the modal
                const modal = new bootstrap.Modal(document.getElementById('composeMessageModal'));
                modal.show();
            });
        } else {
            console.error('Compose button not found');
        }
        
        // Export messages button
        const exportBtn = document.getElementById('export-messages');
        if (exportBtn) {
            console.log('Found export button, attaching event listener');
            exportBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Export button clicked');
                window.exportMessagesInline();
            });
        } else {
            console.error('Export button not found');
        }
        
        // Send composed message button
        const sendBtn = document.getElementById('send-composed-message');
        if (sendBtn) {
            console.log('Found send button, attaching event listener');
            sendBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Send message button clicked');
                window.sendComposedMessageInline();
            });
        } else {
            console.error('Send message button not found');
        }
        
        // Character counter for compose textarea
        const composeText = document.getElementById('compose-text');
        if (composeText) {
            composeText.addEventListener('input', function() {
                const charCount = document.getElementById('char-count');
                if (charCount) {
                    charCount.textContent = this.value.length;
                    if (this.value.length > 4096) {
                        charCount.style.color = 'red';
                    } else {
                        charCount.style.color = '';
                    }
                }
            });
        }
        
        // Message search functionality
        const searchInput = document.getElementById('message-search');
        if (searchInput) {
            console.log('Found message search input, attaching event listener');
            let searchTimeout;
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase().trim();
                console.log('Search input changed:', searchTerm);
                
                // Debounce search to avoid too many operations
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    window.filterMessagesInTable(searchTerm);
                }, 300);
            });
        } else {
            console.error('Message search input not found');
        }
        
        // Session filter dropdown functionality
        const sessionFilter = document.getElementById('session-filter');
        if (sessionFilter) {
            console.log('Found session filter dropdown, attaching event listener');
            sessionFilter.addEventListener('change', function() {
                const selectedSession = this.value;
                console.log('Session filter changed:', selectedSession);
                window.filterMessagesBySession(selectedSession);
            });
        } else {
            console.error('Session filter dropdown not found');
        }
        
        // Refresh session filter button
        const refreshSessionBtn = document.getElementById('refresh-session-filter');
        if (refreshSessionBtn) {
            console.log('Found refresh session filter button, attaching event listener');
            refreshSessionBtn.addEventListener('click', function() {
                console.log('Refresh session filter clicked');
                // Reload sessions and messages
                window.makeApiCall('/api/whatsapp/sessions').then(response => {
                    let sessions = [];
                    if (response && response.success && response.sessions) {
                        sessions = response.sessions;
                    }
                    // Repopulate session dropdown
                    window.populateSessionFilter(sessions);
                    // Reload messages
                    window.loadInlineMessagesData(sessions);
                }).catch(error => {
                    console.error('Error refreshing sessions:', error);
                });
            });
        }
        
    }, 500);
};

// Load sessions for compose modal
window.loadSessionsForCompose = async function() {
    console.log('Loading sessions for compose modal...');
    try {
        const composeSession = document.getElementById('compose-session');
        if (!composeSession) {
            console.error('Compose session dropdown not found');
            return;
        }
        
        composeSession.innerHTML = '<option value="">Loading sessions...</option>';
        
        const response = await window.makeApiCall('/api/whatsapp/sessions');
        console.log('Sessions API response:', response);
        
        let sessions = [];
        if (response && response.success) {
            // The API returns { success: true, sessions: [...] }
            if (response.sessions && Array.isArray(response.sessions)) {
                sessions = response.sessions;
            } else if (response.data && Array.isArray(response.data)) {
                sessions = response.data;
            } else if (response.data && response.data.sessions && Array.isArray(response.data.sessions)) {
                sessions = response.data.sessions;
            }
        }
        
        console.log('Total sessions found:', sessions.length);
        console.log('Sessions data:', sessions);
        
        // Only show connected sessions
        const connectedSessions = sessions.filter(session => {
            console.log(`Session ${session.sessionId}:`, {
                isConnected: session.isConnected,
                connected: session.connected,
                status: session.status
            });
            return session.isConnected === true || session.connected === true || 
                   session.status === 'connected' || session.status === 'ready';
        });
        
        console.log('Connected sessions:', connectedSessions.length);
        
        composeSession.innerHTML = '<option value="">Select a connected session</option>';
        
        if (connectedSessions.length === 0) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = sessions.length > 0 ? 'No connected sessions (connect a session first)' : 'No sessions available (create one first)';
            option.disabled = true;
            composeSession.appendChild(option);
        } else {
            connectedSessions.forEach(session => {
                const option = document.createElement('option');
                option.value = session.sessionId || session.id;
                const phoneText = session.phoneNumber ? ` (${session.phoneNumber})` : '';
                option.textContent = `${session.sessionId || session.id}${phoneText}`;
                composeSession.appendChild(option);
            });
        }
        
        console.log(`✓ Loaded ${connectedSessions.length} connected sessions for compose`);
        
    } catch (error) {
        console.error('Error loading sessions for compose:', error);
        const composeSession = document.getElementById('compose-session');
        if (composeSession) {
            composeSession.innerHTML = '<option value="">Error loading sessions</option>';
        }
    }
};

// Send composed message
window.sendComposedMessageInline = async function() {
    console.log('Sending composed message...');
    try {
        const sessionId = document.getElementById('compose-session').value;
        const phone = document.getElementById('compose-phone').value;
        const text = document.getElementById('compose-text').value;
        const mediaFile = document.getElementById('compose-media').files[0];
        
        if (!sessionId) {
            alert('Please select a session');
            return;
        }
        
        if (!phone) {
            alert('Please enter a phone number');
            return;
        }
        
        if (!text && !mediaFile) {
            alert('Please enter a message or select a media file');
            return;
        }
        
        const sendBtn = document.getElementById('send-composed-message');
        const originalText = sendBtn.innerHTML;
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Sending...';
        
        let response;
        
        if (mediaFile) {
            // Send media message using fetch directly for proper FormData handling
            const formData = new FormData();
            formData.append('to', phone);
            formData.append('media', mediaFile);
            if (text) {
                formData.append('caption', text);
            }
            
            const apiKey = window.getApiKey ? window.getApiKey() : sessionStorage.getItem('apiKey');
            
            const fetchResponse = await fetch(`/api/whatsapp/sessions/${sessionId}/media`, {
                method: 'POST',
                headers: {
                    'x-api-key': apiKey
                },
                body: formData
            });
            
            response = await fetchResponse.json();
        } else {
            // Send text message
            response = await window.makeApiCall(`/api/whatsapp/sessions/${sessionId}/messages`, {
                method: 'POST',
                body: JSON.stringify({
                    to: phone,
                    message: text
                })
            });
        }
        
        if (response && response.success) {
            showToast('Message sent successfully!', 'success');
            
            // Clear form
            document.getElementById('compose-phone').value = '';
            document.getElementById('compose-text').value = '';
            document.getElementById('compose-media').value = '';
            const charCount = document.getElementById('char-count');
            if (charCount) charCount.textContent = '0';
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('composeMessageModal'));
            if (modal) modal.hide();
            
            // Reload messages
            setTimeout(() => {
                if (window.loadInlineMessagesData) {
                    // Get current sessions and reload messages
                    window.makeApiCall('/api/whatsapp/sessions').then(sessionsResponse => {
                        let sessions = [];
                        if (sessionsResponse && sessionsResponse.success && sessionsResponse.sessions) {
                            sessions = sessionsResponse.sessions;
                        }
                        window.loadInlineMessagesData(sessions);
                    });
                }
            }, 1000);
            
        } else {
            throw new Error(response.message || 'Failed to send message');
        }
        
    } catch (error) {
        console.error('Error sending message:', error);
        alert('Error sending message: ' + error.message);
    } finally {
        const sendBtn = document.getElementById('send-composed-message');
        if (sendBtn) {
            sendBtn.disabled = false;
            sendBtn.innerHTML = '<i class="fas fa-send me-2"></i>Send Message';
        }
    }
};

// Export messages to CSV
window.exportMessagesInline = async function() {
    console.log('Exporting messages to CSV...');
    try {
        const exportBtn = document.getElementById('export-messages');
        const originalText = exportBtn.innerHTML;
        exportBtn.disabled = true;
        exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Exporting...';
        
        // Get all messages from all sessions
        console.log('Fetching sessions for export...');
        const sessionsResponse = await window.makeApiCall('/api/whatsapp/sessions');
        console.log('Sessions response for export:', sessionsResponse);
        
        let sessions = [];
        if (sessionsResponse && sessionsResponse.success) {
            if (sessionsResponse.sessions && Array.isArray(sessionsResponse.sessions)) {
                sessions = sessionsResponse.sessions;
            } else if (sessionsResponse.data && Array.isArray(sessionsResponse.data)) {
                sessions = sessionsResponse.data;
            }
        }
        
        console.log(`Found ${sessions.length} sessions for export`);
        
        let allMessages = [];
        for (const session of sessions) {
            try {
                const sessionId = session.sessionId || session.id;
                console.log(`Fetching messages from session ${sessionId} for export...`);
                
                const response = await window.makeApiCall(`/api/whatsapp/sessions/${sessionId}/messages?page=1&limit=1000`);
                console.log(`Messages response for session ${sessionId}:`, response);
                
                let sessionMessages = [];
                if (response && response.success) {
                    if (response.messages && Array.isArray(response.messages)) {
                        sessionMessages = response.messages;
                    } else if (response.data && response.data.messages && Array.isArray(response.data.messages)) {
                        sessionMessages = response.data.messages;
                    }
                    
                    sessionMessages = sessionMessages.map(msg => ({
                        ...msg,
                        sessionId: sessionId
                    }));
                    
                    allMessages = allMessages.concat(sessionMessages);
                    console.log(`Added ${sessionMessages.length} messages from session ${sessionId}`);
                }
            } catch (error) {
                console.warn(`Failed to get messages from session ${session.sessionId || session.id}:`, error);
            }
        }
        
        console.log(`Total messages collected for export: ${allMessages.length}`);
        
        if (allMessages.length === 0) {
            console.log('No messages found via API, trying to export currently displayed messages...');
            
            // Fallback: try to export currently displayed messages from the table
            const messagesTable = document.getElementById('messages-table');
            if (messagesTable && messagesTable.rows.length > 0) {
                console.log('Found messages in table, exporting displayed messages...');
                exportDisplayedMessages();
                return;
            }
            
            alert('No messages found to export. Please ensure you have messages loaded in the table first.');
            return;
        }
        
        // Create CSV content
        const headers = ['Message ID', 'Session', 'Direction', 'Type', 'Status', 'From', 'To', 'Content', 'Created At'];
        const csvContent = [
            headers.join(','),
            ...allMessages.map(msg => {
                const row = [
                    msg.messageId || '',
                    msg.sessionId || '',
                    msg.direction || '',
                    msg.type || '',
                    msg.status || '',
                    msg.from || '',
                    msg.to || '',
                    `"${(msg.content || '').replace(/"/g, '""')}"`, // Escape quotes
                    msg.createdAt || ''
                ];
                return row.join(',');
            })
        ].join('\n');
        
        // Download CSV file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `whatsapp_messages_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert(`Successfully exported ${allMessages.length} messages to CSV`);
        
    } catch (error) {
        console.error('Error exporting messages:', error);
        alert('Error exporting messages: ' + error.message);
    } finally {
        const exportBtn = document.getElementById('export-messages');
        if (exportBtn) {
            exportBtn.disabled = false;
            exportBtn.innerHTML = '<i class="fas fa-file-export me-2"></i>Export CSV';
        }
    }
};

// Export currently displayed messages from table
window.exportDisplayedMessages = function() {
    console.log('Exporting currently displayed messages...');
    try {
        const messagesTable = document.getElementById('messages-table');
        if (!messagesTable || messagesTable.rows.length === 0) {
            alert('No messages currently displayed to export');
            return;
        }
        
        // Extract data from table rows
        const messages = [];
        const rows = messagesTable.querySelectorAll('tr');
        
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 7) {
                const messageData = {
                    messageId: cells[0].textContent.trim(),
                    sessionId: cells[1].textContent.trim(),
                    contact: cells[2].textContent.trim().replace(/[↑↓]/g, '').trim(),
                    content: cells[3].textContent.trim(),
                    type: cells[4].textContent.trim(),
                    status: cells[5].textContent.trim(),
                    timestamp: cells[6].textContent.trim()
                };
                messages.push(messageData);
            }
        });
        
        if (messages.length === 0) {
            alert('No valid message data found in table');
            return;
        }
        
        // Create CSV content
        const headers = ['Message ID', 'Session', 'Contact', 'Content', 'Type', 'Status', 'Timestamp'];
        const csvContent = [
            headers.join(','),
            ...messages.map(msg => {
                const row = [
                    msg.messageId || '',
                    msg.sessionId || '',
                    `"${(msg.contact || '').replace(/"/g, '""')}"`,
                    `"${(msg.content || '').replace(/"/g, '""')}"`,
                    msg.type || '',
                    msg.status || '',
                    msg.timestamp || ''
                ];
                return row.join(',');
            })
        ].join('\n');
        
        // Download CSV file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `displayed_messages_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert(`Successfully exported ${messages.length} displayed messages to CSV`);
        
    } catch (error) {
        console.error('Error exporting displayed messages:', error);
        alert('Error exporting displayed messages: ' + error.message);
    }
};

// Filter messages in table by search term
window.filterMessagesInTable = function(searchTerm) {
    console.log('Filtering messages by search term:', searchTerm);
    
    const messagesTable = document.getElementById('messages-table');
    if (!messagesTable) {
        console.error('Messages table not found for filtering');
        return;
    }
    
    const rows = messagesTable.querySelectorAll('tr');
    let visibleCount = 0;
    
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 7) {
            // Search in message content, contact, and message ID
            const messageId = cells[0].textContent.toLowerCase();
            const contact = cells[2].textContent.toLowerCase();
            const content = cells[3].textContent.toLowerCase();
            const type = cells[4].textContent.toLowerCase();
            const status = cells[5].textContent.toLowerCase();
            
            const matchesSearch = !searchTerm || 
                messageId.includes(searchTerm) ||
                contact.includes(searchTerm) ||
                content.includes(searchTerm) ||
                type.includes(searchTerm) ||
                status.includes(searchTerm);
            
            if (matchesSearch) {
                row.style.display = '';
                visibleCount++;
            } else {
                row.style.display = 'none';
            }
        }
    });
    
    console.log(`Search results: ${visibleCount} messages match "${searchTerm}"`);
    
    // Show/hide empty state
    const messagesEmpty = document.getElementById('messages-empty');
    if (messagesEmpty) {
        if (visibleCount === 0 && searchTerm) {
            // Show custom "no results" message
            messagesTable.innerHTML = `
                <tr>
                    <td colspan="7" class="text-center py-4">
                        <i class="fas fa-search fa-2x text-muted mb-2"></i>
                        <h6 class="text-muted">No messages found</h6>
                        <p class="text-muted">No messages match your search term "${searchTerm}"</p>
                        <button class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('message-search').value=''; window.filterMessagesInTable('');">
                            Clear Search
                        </button>
                    </td>
                </tr>
            `;
        }
    }
};

// Filter messages by session
window.filterMessagesBySession = function(sessionId) {
    console.log('Filtering messages by session:', sessionId);
    
    if (!sessionId) {
        // Show all messages - reload from API
        console.log('Showing all messages');
        window.makeApiCall('/api/whatsapp/sessions').then(response => {
            let sessions = [];
            if (response && response.success && response.sessions) {
                sessions = response.sessions;
            }
            window.loadInlineMessagesData(sessions);
        });
        return;
    }
    
    // Filter current table by session
    const messagesTable = document.getElementById('messages-table');
    if (!messagesTable) {
        console.error('Messages table not found for session filtering');
        return;
    }
    
    const rows = messagesTable.querySelectorAll('tr');
    let visibleCount = 0;
    
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 7) {
            const messageSessionId = cells[1].textContent.trim();
            
            if (messageSessionId === sessionId) {
                row.style.display = '';
                visibleCount++;
            } else {
                row.style.display = 'none';
            }
        }
    });
    
    console.log(`Session filter results: ${visibleCount} messages from session "${sessionId}"`);
    
    if (visibleCount === 0) {
        messagesTable.innerHTML = `
            <tr>
                <td colspan="7" class="text-center py-4">
                    <i class="fas fa-filter fa-2x text-muted mb-2"></i>
                    <h6 class="text-muted">No messages found</h6>
                    <p class="text-muted">No messages found for session "${sessionId}"</p>
                    <button class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('session-filter').value=''; window.filterMessagesBySession('');">
                        Show All Sessions
                    </button>
                </td>
            </tr>
        `;
    }
};

// Populate session filter dropdown
window.populateSessionFilter = function(sessions) {
    console.log('Populating session filter with sessions:', sessions);
    
    const sessionFilter = document.getElementById('session-filter');
    if (!sessionFilter) {
        console.error('Session filter dropdown not found');
        return;
    }
    
    sessionFilter.innerHTML = '<option value="">All Sessions</option>';
    
    if (sessions.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No sessions found';
        option.disabled = true;
        sessionFilter.appendChild(option);
        return;
    }
    
    sessions.forEach(session => {
        const option = document.createElement('option');
        const sessionId = session.sessionId || session.id;
        option.value = sessionId;
        
        // Show connection status
        let statusText = '';
        if (session.isConnected === true || session.connected === true || 
            session.status === 'connected' || session.status === 'ready') {
            statusText = ' ✓ Connected';
        } else {
            statusText = ' ✗ Disconnected';
        }
        
        const phoneText = session.phoneNumber ? ` (${session.phoneNumber})` : '';
        option.textContent = `${sessionId}${phoneText}${statusText}`;
        sessionFilter.appendChild(option);
    });
    
    console.log(`Added ${sessions.length} sessions to filter dropdown`);
};

// ============================================================================
// CHATBOT MANAGEMENT - Production Ready
// ============================================================================

// Load chatbot data and initialize chatbot management
window.loadChatbotData = async function() {
    console.log('Loading chatbot data...');
    try {
        // Load sessions for bot creation
        await loadSessionsForBot();
        
        // Load existing bot
        await loadBotConfiguration();
        
        // Initialize event listeners
        initializeChatbotEventListeners();
        
        // Check AI status
        checkAIStatus();
        
    } catch (error) {
        console.error('Error loading chatbot data:', error);
        showToast('Failed to load chatbot data', 'error');
    }
};

// Load sessions for bot creation
async function loadSessionsForBot() {
    try {
        const response = await makeApiCall('/api/whatsapp/sessions');
        let sessions = [];
        
        if (response && response.success && response.data) {
            sessions = Array.isArray(response.data) ? response.data : 
                      (response.data.sessions || []);
        }
        
        const sessionSelect = document.getElementById('bot-session-id');
        if (sessionSelect) {
            sessionSelect.innerHTML = '<option value="">Select a session...</option>' +
                sessions.filter(s => s.status === 'connected').map(session => `
                    <option value="${session._id}">${session.sessionId} - ${session.phoneNumber || 'No phone'}</option>
                `).join('');
        }
    } catch (error) {
        console.error('Error loading sessions:', error);
    }
}

// Load bot configuration
async function loadBotConfiguration() {
    try {
        const response = await makeApiCall('/api/bot');
        
        if (response && response.success && response.data && response.data.length > 0) {
            const bot = response.data[0]; // Get first bot
            const flows = bot.flows || [];
            
            // Update botManager
            window.botManager.setCurrentBot(bot);
            window.botManager.setCurrentFlows(flows);
            
            updateBotUI();
        } else {
            window.botManager.setCurrentBot(null);
            window.botManager.setCurrentFlows([]);
            updateBotUI();
        }
    } catch (error) {
        console.error('Error loading bot:', error);
        window.botManager.setCurrentBot(null);
        window.botManager.setCurrentFlows([]);
        updateBotUI();
    }
}

// Update bot UI
function updateBotUI() {
    const currentBot = window.botManager.currentBot();
    const currentFlows = window.botManager.currentFlows();
    
    // Update bot status card
    if (currentBot) {
        document.getElementById('bot-name').textContent = currentBot.name;
        document.getElementById('bot-description').textContent = currentBot.description || 'No description';
        document.getElementById('bot-status-badge').textContent = currentBot.isActive ? 'Active' : 'Inactive';
        document.getElementById('bot-status-badge').className = `badge ${currentBot.isActive ? 'bg-success' : 'bg-secondary'}`;
        document.getElementById('bot-flows-count').textContent = `${currentFlows.length} Flows`;
        
        // Update analytics
        document.getElementById('bot-total-conversations').textContent = currentBot.analytics?.totalConversations || 0;
        document.getElementById('bot-total-messages').textContent = currentBot.analytics?.totalMessages || 0;
        document.getElementById('bot-last-used').textContent = currentBot.analytics?.lastUsed ? 
            new Date(currentBot.analytics.lastUsed).toLocaleString() : 'Never';
        
        // Enable buttons
        document.getElementById('toggle-bot-btn').disabled = false;
        document.getElementById('edit-bot-btn').disabled = false;
        document.getElementById('add-flow-btn').disabled = false;
        document.getElementById('test-message-input').disabled = false;
        document.getElementById('test-bot-btn').disabled = false;
        
        // Update toggle button
        const toggleBtn = document.getElementById('toggle-bot-btn');
        toggleBtn.innerHTML = currentBot.isActive ? 
            '<i class="fas fa-pause me-2"></i>Deactivate Bot' : 
            '<i class="fas fa-play me-2"></i>Activate Bot';
        toggleBtn.className = currentBot.isActive ? 'btn btn-sm btn-outline-warning' : 'btn btn-sm btn-outline-success';
        
        // Render flows
        renderFlows();
    } else {
        document.getElementById('bot-name').textContent = 'No Bot Configured';
        document.getElementById('bot-description').textContent = 'Create a bot to start automating conversations';
        document.getElementById('bot-status-badge').textContent = 'Inactive';
        document.getElementById('bot-status-badge').className = 'badge bg-secondary';
        document.getElementById('bot-flows-count').textContent = '0 Flows';
        
        // Reset analytics
        document.getElementById('bot-total-conversations').textContent = '0';
        document.getElementById('bot-total-messages').textContent = '0';
        document.getElementById('bot-last-used').textContent = 'Never';
        
        // Disable buttons
        document.getElementById('toggle-bot-btn').disabled = true;
        document.getElementById('edit-bot-btn').disabled = true;
        document.getElementById('add-flow-btn').disabled = true;
        document.getElementById('test-message-input').disabled = true;
        document.getElementById('test-bot-btn').disabled = true;
        
        // Show empty state
        const flowsContainer = document.getElementById('bot-flows-container');
        if (flowsContainer) {
            flowsContainer.innerHTML = `
                <div class="text-center py-5">
                    <i class="fas fa-robot fa-4x text-muted mb-3"></i>
                    <h5 class="text-muted">No Bot Configured</h5>
                    <p class="text-muted">Create a bot to start adding conversation flows</p>
                    <button class="btn btn-primary" onclick="document.getElementById('create-bot-btn').click()">
                        <i class="fas fa-plus me-2"></i>Create Your First Bot
                    </button>
                </div>
            `;
        }
    }
}

// Render flows
function renderFlows() {
    const currentFlows = window.botManager.currentFlows();
    const container = document.getElementById('bot-flows-container');
    if (!container) return;
    
    if (!currentFlows || currentFlows.length === 0) {
        container.innerHTML = `
            <div class="text-center py-4">
                <i class="fas fa-stream fa-3x text-muted mb-3"></i>
                <h5 class="text-muted">No Flows Yet</h5>
                <p class="text-muted">Add your first conversation flow</p>
                <button class="btn btn-primary" onclick="openFlowModal()">
                    <i class="fas fa-plus me-2"></i>Add First Flow
                </button>
            </div>
        `;
        return;
    }
    
    container.innerHTML = currentFlows.map(flow => `
        <div class="card flow-card mb-3">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-start mb-3">
                    <div>
                        <h6 class="mb-1">${flow.name}</h6>
                        <small class="text-muted">
                            <i class="fas fa-bolt me-1"></i>
                            Trigger: <strong>${flow.trigger?.value || 'N/A'}</strong>
                        </small>
                    </div>
                    <div class="d-flex gap-2">
                        <span class="badge ${flow.isActive ? 'bg-success' : 'bg-secondary'}">
                            ${flow.isActive ? 'Active' : 'Inactive'}
                        </span>
                        <div class="dropdown">
                            <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="dropdown">
                                <i class="fas fa-ellipsis-v"></i>
                            </button>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#" onclick="editFlow('${flow.id}')">
                                    <i class="fas fa-edit me-2"></i>Edit
                                </a></li>
                                <li><a class="dropdown-item" href="#" onclick="deleteFlow('${flow.id}')">
                                    <i class="fas fa-trash me-2 text-danger"></i>Delete
                                </a></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="responses-list">
                    <small class="text-muted d-block mb-2">
                        <i class="fas fa-reply me-1"></i>Responses (${flow.responses?.length || 0}):
                    </small>
                    ${(flow.responses || []).map((resp, idx) => `
                        <div class="response-item p-2 mb-2 rounded">
                            <small>
                                <strong>${idx + 1}.</strong> 
                                <span class="badge bg-primary">${resp.type}</span>
                                ${resp.content ? resp.content.substring(0, 50) + '...' : 'No content'}
                                ${resp.delay ? `<span class="badge bg-info ms-2">${resp.delay}ms delay</span>` : ''}
                            </small>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `).join('');
}

// Check AI status
function checkAIStatus() {
    // This would check if AI is configured
    // For now, we'll assume it's enabled based on environment
    const aiEnabled = true; // This should come from backend
    const aiStatus = document.getElementById('ai-status-indicator');
    if (aiStatus) {
        aiStatus.textContent = aiEnabled ? 'Enabled' : 'Disabled';
        aiStatus.className = `badge ${aiEnabled ? 'bg-success' : 'bg-secondary'}`;
    }
}

// Initialize event listeners
function initializeChatbotEventListeners() {
    // Create Bot
    const createBotBtn = document.getElementById('create-bot-btn');
    if (createBotBtn) {
        createBotBtn.onclick = () => openBotModal();
    }
    
    // Edit Bot
    const editBotBtn = document.getElementById('edit-bot-btn');
    if (editBotBtn) {
        editBotBtn.onclick = () => openBotModal(window.botManager.currentBot());
    }
    
    // Toggle Bot
    const toggleBotBtn = document.getElementById('toggle-bot-btn');
    if (toggleBotBtn) {
        toggleBotBtn.onclick = () => toggleBot();
    }
    
    // Refresh
    const refreshBtn = document.getElementById('refresh-bot-btn');
    if (refreshBtn) {
        refreshBtn.onclick = () => loadBotConfiguration();
    }
    
    // Add Flow
    const addFlowBtn = document.getElementById('add-flow-btn');
    if (addFlowBtn) {
        addFlowBtn.onclick = () => openFlowModal();
    }
    
    // Save Bot
    const saveBotBtn = document.getElementById('save-bot-btn');
    if (saveBotBtn) {
        saveBotBtn.onclick = () => saveBot();
    }
    
    // Save Flow
    const saveFlowBtn = document.getElementById('save-flow-btn');
    if (saveFlowBtn) {
        saveFlowBtn.onclick = () => saveFlow();
    }
    
    // Test Bot
    const testBotBtn = document.getElementById('test-bot-btn');
    if (testBotBtn) {
        testBotBtn.onclick = () => testBot();
    }
    
    // Add Response
    const addResponseBtn = document.getElementById('add-response-btn');
    if (addResponseBtn) {
        addResponseBtn.onclick = () => addResponse();
    }
    
    // Working hours toggle
    const workingHoursToggle = document.getElementById('bot-working-hours-enabled');
    if (workingHoursToggle) {
        workingHoursToggle.onchange = function() {
            document.getElementById('working-hours-config').style.display = 
                this.checked ? 'block' : 'none';
        };
    }
}

// Initialize webhook management buttons
window.initializeWebhookButtons = function() {
    console.log('Initializing webhook management buttons...');
    
    // Add webhook button
    const addWebhookBtn = document.getElementById('add-webhook-btn');
    if (addWebhookBtn) {
        console.log('Found add webhook button, attaching event listener');
        addWebhookBtn.addEventListener('click', function(e) {
            e.preventDefault();
            console.log('Add webhook button clicked');
            window.showAddWebhookModal();
        });
    } else {
        console.error('Add webhook button not found');
    }
    
    // Initialize existing webhook buttons
    window.initializeWebhookActionButtons();
};

// ===== COMPREHENSIVE WEBHOOK MANAGEMENT FUNCTIONS =====

// Initialize webhooks page - make it globally available
window.initializeWebhooksPage = function() {
    console.log('Initializing webhooks page...');
    
    // Load initial data
    loadWebhooksData();
    loadSupportedEvents();

    // Initialize event listeners
    initializeWebhookEventListeners();
};

// Load webhooks data with comprehensive functionality
async function loadWebhooksData() {
    console.log('Loading webhooks data...');
    try {
        const response = await makeApiCall('/api/webhooks');
        
        if (response && response.success) {
            const webhooks = response.data || [];
            renderWebhooksTable(webhooks);
            updateWebhookStatistics(webhooks);
            return webhooks;
        } else {
            throw new Error(response?.message || 'Failed to load webhooks');
        }
    } catch (error) {
        console.error('Error loading webhooks:', error);
        showWebhooksError('Failed to load webhooks: ' + error.message);
        return [];
    }
}

// Render webhooks table with all functionality
function renderWebhooksTable(webhooks) {
    const tableBody = document.getElementById('webhooks-table-body');
    if (!tableBody) return;

    if (!webhooks || webhooks.length === 0) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center py-4">
                    <div class="text-muted">
                        <i class="fas fa-webhook fa-3x mb-3 opacity-50"></i>
                        <h5>No Webhooks Found</h5>
                        <p>Create your first webhook to start receiving real-time notifications.</p>
                        <button class="btn btn-primary" onclick="showAddWebhookModal()">
                            <i class="fas fa-plus me-2"></i>Add Webhook
                        </button>
                    </div>
                </td>
            </tr>
        `;
        return;
    }

    tableBody.innerHTML = webhooks.map((webhook, index) => {
        const successRate = webhook.successCount + webhook.failureCount > 0 
            ? Math.round((webhook.successCount / (webhook.successCount + webhook.failureCount)) * 100)
            : 0;
        
        const statusBadge = webhook.isActive 
            ? '<span class="badge bg-success">Active</span>'
            : '<span class="badge bg-secondary">Inactive</span>';
        
        const lastDelivery = webhook.lastTriggeredAt 
            ? formatRelativeTime(webhook.lastTriggeredAt)
            : 'Never';

        const eventBadges = webhook.events.slice(0, 3).map(event => 
            `<span class="badge bg-primary me-1">${event}</span>`
        ).join('');
        
        const moreEvents = webhook.events.length > 3 
            ? `<span class="badge bg-light text-dark">+${webhook.events.length - 3} more</span>`
            : '';

        return `
            <tr>
                <td>
                    <input type="checkbox" class="form-check-input webhook-checkbox" 
                           value="${webhook._id}" data-webhook-id="${webhook._id}">
                </td>
                <td>
                    <div class="d-flex flex-column">
                        <span class="fw-bold">${webhook.url}</span>
                        ${webhook.description ? `<small class="text-muted">${webhook.description}</small>` : ''}
                    </div>
                </td>
                <td>
                    <div class="d-flex flex-wrap gap-1">
                        ${eventBadges}
                        ${moreEvents}
                    </div>
                </td>
                <td>${statusBadge}</td>
                <td>
                    <div class="d-flex align-items-center">
                        <div class="progress me-2" style="width: 60px; height: 8px;">
                            <div class="progress-bar ${successRate >= 80 ? 'bg-success' : successRate >= 50 ? 'bg-warning' : 'bg-danger'}" 
                                 style="width: ${successRate}%"></div>
                        </div>
                        <span class="small">${successRate}%</span>
                    </div>
                    <small class="text-muted">${webhook.successCount}/${webhook.successCount + webhook.failureCount}</small>
                </td>
                <td>
                    <span class="small">${lastDelivery}</span>
                </td>
                <td>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-primary" onclick="showWebhookDetails('${webhook._id}')" 
                                title="View Details">
                            <i class="fas fa-eye"></i>
                        </button>
                        <button class="btn btn-outline-success" onclick="testWebhookNew('${webhook._id}')" 
                                title="Test Webhook">
                            <i class="fas fa-vial"></i>
                        </button>
                        <button class="btn btn-outline-secondary" onclick="editWebhookNew('${webhook._id}')" 
                                title="Edit Webhook">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-outline-danger" onclick="deleteWebhookNew('${webhook._id}')" 
                                title="Delete Webhook">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');

    // Initialize checkbox functionality
    initializeWebhookCheckboxes();
}

// Helper function to update DOM elements
function updateElement(id, value) {
    const element = document.getElementById(id);
    if (element) {
        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
            element.value = value;
        } else {
            element.textContent = value;
        }
        console.log(`Updated ${id}:`, value);
    } else {
        console.log(`Element with id '${id}' not found (this is normal if not on webhooks page)`);
    }
}

// Helper functions for loading states and notifications
function showLoading(message) {
    // Simple loading implementation - you can enhance this with a proper modal
    console.log('Loading:', message);
    // You could show a loading spinner or disable buttons here
}

function hideLoading() {
    console.log('Loading complete');
    // Hide loading spinner or re-enable buttons here
}

function showSuccess(message) {
    alert('✅ ' + message);
    console.log('Success:', message);
}

function showError(message) {
    alert('❌ ' + message);
    console.error('Error:', message);
}

// Helper function to format relative time
function formatRelativeTime(timestamp) {
    const now = new Date();
    const time = new Date(timestamp);
    const diffMs = now - time;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    return time.toLocaleDateString();
}

// Update webhook statistics
function updateWebhookStatistics(webhooks) {
    const totalWebhooks = webhooks.length;
    const activeWebhooks = webhooks.filter(w => w.isActive).length;
    const totalDeliveries = webhooks.reduce((sum, w) => sum + w.successCount + w.failureCount, 0);
    const successfulDeliveries = webhooks.reduce((sum, w) => sum + w.successCount, 0);
    const successRate = totalDeliveries > 0 ? Math.round((successfulDeliveries / totalDeliveries) * 100) : 0;

    updateElement('total-webhooks', totalWebhooks);
    updateElement('active-webhooks', activeWebhooks);
    updateElement('total-deliveries', totalDeliveries);
    updateElement('success-rate', successRate + '%');
}

// Load supported events
async function loadSupportedEvents() {
    try {
        const response = await makeApiCall('/api/webhooks/events/supported');
        
        if (response && response.success) {
            const events = response.data || [];
            renderSupportedEvents(events);
            populateEventFilters(events);
            return events;
        }
    } catch (error) {
        console.error('Error loading supported events:', error);
        // Fallback to default events
        const defaultEvents = [
            'message.received', 'message.sent', 'message.delivered', 'message.read', 'message.failed',
            'session.connected', 'session.disconnected', 'session.qr_updated', 'session.error'
        ];
        renderSupportedEvents(defaultEvents);
        populateEventFilters(defaultEvents);
        return defaultEvents;
    }
}

// Render supported events list
function renderSupportedEvents(events) {
    const container = document.getElementById('supported-events-list');
    if (!container) return;

    container.innerHTML = events.map(event => {
        const eventType = event.split('.')[0];
        const eventAction = event.split('.')[1];
        const badgeClass = getEventBadgeClass(eventType);
        
        return `
            <div class="d-flex justify-content-between align-items-center mb-2">
                <code class="small">${event}</code>
                <span class="badge ${badgeClass}">${eventAction}</span>
            </div>
        `;
    }).join('');
}

// Populate event filters
function populateEventFilters(events) {
    const eventFilter = document.getElementById('event-filter');
    if (!eventFilter) return;

    const uniqueEventTypes = [...new Set(events.map(event => event.split('.')[0]))];
    
    eventFilter.innerHTML = '<option value="">All Events</option>' + 
        uniqueEventTypes.map(eventType => 
            `<option value="${eventType}">${eventType.charAt(0).toUpperCase() + eventType.slice(1)}</option>`
        ).join('');
}

// Show add webhook modal
function showAddWebhookModal() {
    const modal = new bootstrap.Modal(document.getElementById('webhookModal'));
    document.querySelector('#webhookModal .modal-title').textContent = 'Add Webhook';
    document.getElementById('webhook-form').reset();
    
    // Load events for selection
    loadSupportedEvents().then(events => {
        populateWebhookEvents(events);
    });
    
    modal.show();
}

// Populate webhook events in modal
function populateWebhookEvents(events) {
    const container = document.getElementById('webhook-events');
    if (!container) return;

    container.innerHTML = events.map(event => `
        <div class="form-check">
            <input class="form-check-input" type="checkbox" value="${event}" id="event-${event.replace('.', '-')}">
            <label class="form-check-label" for="event-${event.replace('.', '-')}">
                ${event}
            </label>
        </div>
    `).join('');
}

// Populate edit modal with webhook data
function populateEditModal(webhook) {
    // Populate form fields
    document.getElementById('webhook-name').value = webhook.name || '';
    document.getElementById('webhook-url').value = webhook.url || '';
    document.getElementById('webhook-timeout').value = webhook.timeout || 30;
    document.getElementById('webhook-retries').value = webhook.retryPolicy?.maxAttempts || 3;
    document.getElementById('webhook-secret').value = webhook.secret || '';
    document.getElementById('webhook-description').value = webhook.description || '';
    document.getElementById('webhook-active').checked = webhook.isActive || false;

    // Load events and select the webhook's events
    loadSupportedEvents().then(events => {
        populateWebhookEvents(events);
        
        // Select the webhook's events
        webhook.events.forEach(event => {
            const checkbox = document.getElementById(`event-${event.replace('.', '-')}`);
            if (checkbox) {
                checkbox.checked = true;
            }
        });
    });
}

// Test webhook (new implementation)
async function testWebhookNew(webhookId) {
    try {
        showLoading('Testing webhook...');
        
        const response = await makeApiCall(`/api/webhooks/${webhookId}/test`, {
            method: 'POST'
        });

        hideLoading();

        if (response && response.success) {
            showSuccess(`Webhook test successful! Response time: ${response.data.responseTime}ms`);
        } else {
            throw new Error(response?.message || 'Webhook test failed');
        }
    } catch (error) {
        hideLoading();
        console.error('Error testing webhook:', error);
        showError('Webhook test failed: ' + error.message);
    }
}

// Edit webhook (new implementation)
function editWebhookNew(webhookId) {
    // Load webhook details and populate modal
    loadWebhookDetails(webhookId).then(webhook => {
        if (webhook) {
            populateEditModal(webhook);
            const modal = new bootstrap.Modal(document.getElementById('webhookModal'));
            document.querySelector('#webhookModal .modal-title').textContent = 'Edit Webhook';
            modal.show();
        }
    });
}

// Delete webhook (new implementation)
async function deleteWebhookNew(webhookId) {
    if (!confirm('Are you sure you want to delete this webhook? This action cannot be undone.')) {
        return;
    }

    try {
        showLoading('Deleting webhook...');
        
        const response = await makeApiCall(`/api/webhooks/${webhookId}`, {
            method: 'DELETE'
        });

        hideLoading();

        if (response && response.success) {
            await loadWebhooksData();
            showSuccess('Webhook deleted successfully!');
        } else {
            throw new Error(response?.message || 'Failed to delete webhook');
        }
    } catch (error) {
        hideLoading();
        console.error('Error deleting webhook:', error);
        showError('Failed to delete webhook: ' + error.message);
    }
}

// Load webhook details
async function loadWebhookDetails(webhookId) {
    try {
        const response = await makeApiCall(`/api/webhooks/${webhookId}`);
        
        if (response && response.success) {
            return response.data;
        } else {
            throw new Error(response?.message || 'Failed to load webhook details');
        }
    } catch (error) {
        console.error('Error loading webhook details:', error);
        showError('Failed to load webhook details: ' + error.message);
        return null;
    }
}

// Show webhook details modal
async function showWebhookDetails(webhookId) {
    try {
        const webhook = await loadWebhookDetails(webhookId);
        if (!webhook) return;

        // Populate details modal
        document.getElementById('detail-name').textContent = webhook.name || webhook.url;
        document.getElementById('detail-url').textContent = webhook.url;
        document.getElementById('detail-status').innerHTML = webhook.isActive 
            ? '<span class="badge bg-success">Active</span>'
            : '<span class="badge bg-secondary">Inactive</span>';
        document.getElementById('detail-created').textContent = new Date(webhook.createdAt).toLocaleString();
        document.getElementById('detail-success').textContent = webhook.successCount || 0;
        document.getElementById('detail-failure').textContent = webhook.failureCount || 0;
        
        const successRate = webhook.successCount + webhook.failureCount > 0 
            ? Math.round((webhook.successCount / (webhook.successCount + webhook.failureCount)) * 100)
            : 0;
        document.getElementById('detail-rate').textContent = successRate + '%';
        
        document.getElementById('detail-last-triggered').textContent = webhook.lastTriggeredAt 
            ? new Date(webhook.lastTriggeredAt).toLocaleString()
            : 'Never';

        // Render events
        const eventsContainer = document.getElementById('detail-events');
        eventsContainer.innerHTML = webhook.events.map(event => 
            `<span class="badge bg-primary me-1 mb-1">${event}</span>`
        ).join('');

        // Load logs
        loadWebhookLogs(webhookId);

        const modal = new bootstrap.Modal(document.getElementById('webhookDetailsModal'));
        modal.show();
    } catch (error) {
        console.error('Error showing webhook details:', error);
        showError('Failed to load webhook details: ' + error.message);
    }
}

// Load webhook logs
async function loadWebhookLogs(webhookId) {
    try {
        const response = await makeApiCall(`/api/webhooks/${webhookId}/logs?limit=10`);
        
        const logsContainer = document.getElementById('detail-logs');
        
        if (response && response.success && response.data.length > 0) {
            logsContainer.innerHTML = response.data.map(log => `
                <div class="d-flex justify-content-between align-items-center border-bottom py-2">
                    <div>
                        <span class="badge ${log.success ? 'bg-success' : 'bg-danger'}">${log.event}</span>
                        ${log.error ? `<small class="text-danger d-block">${log.error}</small>` : ''}
                    </div>
                    <div class="text-end">
                        <small class="text-muted">${new Date(log.timestamp).toLocaleString()}</small>
                        ${log.responseTime ? `<small class="d-block text-muted">${log.responseTime}ms</small>` : ''}
                    </div>
                </div>
            `).join('');
        } else {
            logsContainer.innerHTML = '<div class="text-center text-muted py-3">No logs available</div>';
        }
    } catch (error) {
        console.error('Error loading webhook logs:', error);
        document.getElementById('detail-logs').innerHTML = 
            '<div class="text-center text-danger py-3">Failed to load logs</div>';
    }
}

// Initialize webhook checkboxes
function initializeWebhookCheckboxes() {
    const selectAll = document.getElementById('select-all-webhooks');
    const checkboxes = document.querySelectorAll('.webhook-checkbox');

    if (selectAll) {
        selectAll.addEventListener('change', function() {
            checkboxes.forEach(cb => cb.checked = this.checked);
        });
    }

    checkboxes.forEach(cb => {
        cb.addEventListener('change', function() {
            const allChecked = Array.from(checkboxes).every(c => c.checked);
            const someChecked = Array.from(checkboxes).some(c => c.checked);
            
            if (selectAll) {
                selectAll.checked = allChecked;
                selectAll.indeterminate = someChecked && !allChecked;
            }
        });
    });
}

// Initialize webhook event listeners
function initializeWebhookEventListeners() {
    // Add webhook button
    const addWebhookBtn = document.getElementById('add-webhook-btn');
    if (addWebhookBtn) {
        addWebhookBtn.addEventListener('click', showAddWebhookModal);
    }

    // Refresh button
    const refreshBtn = document.getElementById('refresh-webhooks-btn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
            refreshBtn.disabled = true;
            loadWebhooksData().finally(() => {
                refreshBtn.disabled = false;
            });
        });
    }

    // Webhook form submission
    const webhookForm = document.getElementById('webhook-form');
    if (webhookForm) {
        webhookForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(webhookForm);
            await saveWebhook(formData);
        });
    }

    // Quick test form
    const quickTestForm = document.getElementById('quick-test-form');
    if (quickTestForm) {
        quickTestForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const url = document.getElementById('test-url').value;
            await quickTestWebhook(url);
        });
    }
}

// Save webhook
async function saveWebhook(formData) {
    try {
        const selectedEvents = Array.from(document.querySelectorAll('#webhook-events input:checked'))
            .map(input => input.value);

        if (selectedEvents.length === 0) {
            throw new Error('Please select at least one event');
        }

        const webhookData = {
            name: formData.get('name'),
            url: formData.get('url'),
            events: selectedEvents,
            secret: formData.get('secret') || undefined,
            timeout: parseInt(formData.get('timeout')) || 30,
            retryAttempts: parseInt(formData.get('retryAttempts')) || 3,
            description: formData.get('description') || undefined,
            isActive: formData.has('isActive')
        };

        const response = await makeApiCall('/api/webhooks', {
            method: 'POST',
            body: JSON.stringify(webhookData)
        });

        if (response && response.success) {
            const modal = bootstrap.Modal.getInstance(document.getElementById('webhookModal'));
            modal.hide();
            
            await loadWebhooksData();
            showSuccess('Webhook created successfully!');
        } else {
            throw new Error(response?.message || 'Failed to create webhook');
        }
    } catch (error) {
        console.error('Error saving webhook:', error);
        showError('Failed to create webhook: ' + error.message);
    }
}

// Quick test webhook URL
async function quickTestWebhook(url) {
    try {
        showLoading('Testing webhook URL...');
        
        const response = await makeApiCall('/api/webhooks/test-url', {
            method: 'POST',
            body: JSON.stringify({ webhookUrl: url })
        });

        hideLoading();

        if (response && response.success) {
            showSuccess(`Webhook test successful! Response time: ${response.data.responseTime}ms`);
        } else {
            throw new Error(response?.message || 'Webhook test failed');
        }
    } catch (error) {
        hideLoading();
        console.error('Error testing webhook URL:', error);
        showError('Webhook test failed: ' + error.message);
    }
}

// Helper functions for webhooks
function getEventBadgeClass(eventType) {
    const badgeClasses = {
        'message': 'bg-primary',
        'session': 'bg-info',
        'contact': 'bg-success',
        'group': 'bg-warning',
        'call': 'bg-secondary'
    };
    return badgeClasses[eventType] || 'bg-secondary';
}

function showWebhooksError(message) {
    const tableBody = document.getElementById('webhooks-table-body');
    if (tableBody) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center py-4">
                    <div class="text-danger">
                        <i class="fas fa-exclamation-triangle fa-2x mb-3"></i>
                        <h5>Error Loading Webhooks</h5>
                        <p>${message}</p>
                        <button class="btn btn-outline-primary" onclick="loadWebhooksData()">
                            <i class="fas fa-retry me-2"></i>Retry
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }
}

// Make functions globally available
window.loadWebhooksData = loadWebhooksData;
window.showAddWebhookModal = showAddWebhookModal;
window.testWebhookNew = testWebhookNew;
window.editWebhookNew = editWebhookNew;
window.deleteWebhookNew = deleteWebhookNew;
window.showWebhookDetails = showWebhookDetails;

// ===== COMPREHENSIVE ANALYTICS MANAGEMENT FUNCTIONS =====

// Global analytics state
let currentAnalyticsPeriod = '30d';
let analyticsCharts = {};

// Initialize analytics page - make it globally available
window.initializeAnalyticsPage = function() {
    console.log('Initializing analytics page...');
    initializeAnalyticsManually();
};

// Initialize analytics manually when window.initializeAnalyticsPage is not available
function initializeAnalyticsManually() {
    console.log('Initializing analytics manually...');
    
    // Load initial data
    loadAnalyticsData();
    
    // Initialize event listeners
    initializeAnalyticsEventListeners();
}

// Load analytics data with comprehensive functionality
async function loadAnalyticsData(period = currentAnalyticsPeriod) {
    console.log('Loading analytics data for period:', period);
    currentAnalyticsPeriod = period;
    
    try {
        // Load all analytics data in parallel
        await Promise.all([
            loadAnalyticsMetrics(period),
            loadVolumeChart(period),
            loadStatusChart(),
            loadTopContacts(period),
            loadSessionAnalytics(period),
            loadMessageTypes()
        ]);
        
        console.log('All analytics data loaded successfully');
    } catch (error) {
        console.error('Error loading analytics data:', error);
        showAnalyticsError('Failed to load analytics data: ' + error.message);
    }
}

// Load analytics metrics
async function loadAnalyticsMetrics(period = '30d') {
    try {
        const response = await makeApiCall(`/api/analytics/dashboard?period=${period}`);
        
        if (response && response.success) {
            const data = response.data;
            updateAnalyticsMetrics(data);
        } else {
            throw new Error(response?.message || 'Failed to load metrics');
        }
    } catch (error) {
        console.error('Error loading analytics metrics:', error);
        showMetricsError();
    }
}

// Update analytics metrics display
function updateAnalyticsMetrics(data) {
    const overview = data.overview || {};
    const messageStatus = data.messageStatus || {};
    
    // Calculate delivery rate
    const totalSent = overview.sentMessages || 0;
    const delivered = messageStatus.delivered || 0;
    const deliveryRate = totalSent > 0 ? ((delivered / totalSent) * 100).toFixed(1) : '0.0';
    
    // Update metrics
    updateElement('delivery-rate', deliveryRate + '%');
    updateElement('total-messages', formatNumber(overview.totalMessages || 0));
    updateElement('active-sessions', overview.activeSessions || 0);
    
    // Calculate message types count
    const messageTypes = Object.keys(data.messageTypes || {}).length;
    updateElement('message-types', messageTypes);
    
    // Update change indicators (placeholder for now)
    updateElement('delivery-rate-change', 'Last ' + currentAnalyticsPeriod);
    updateElement('total-messages-change', 'Last ' + currentAnalyticsPeriod);
    updateElement('active-sessions-change', 'Current active');
    updateElement('message-types-change', 'Types used');
}

// Load volume chart
async function loadVolumeChart(period = '7d') {
    const canvas = document.getElementById('volumeChart');
    const loadingDiv = document.getElementById('volume-chart-loading');
    const errorDiv = document.getElementById('volume-chart-error');
    
    if (!canvas) return;
    
    try {
        // Show loading
        loadingDiv.style.display = 'block';
        canvas.style.display = 'none';
        errorDiv.style.display = 'none';
        
        const response = await makeApiCall(`/api/analytics/messages?period=${period}`);
        
        if (response && response.success) {
            const timeSeries = response.data.timeSeries || [];
            await createVolumeChart(canvas, timeSeries);
            
            // Show chart
            loadingDiv.style.display = 'none';
            canvas.style.display = 'block';
        } else {
            throw new Error(response?.message || 'Failed to load chart data');
        }
    } catch (error) {
        console.error('Error loading volume chart:', error);
        loadingDiv.style.display = 'none';
        errorDiv.style.display = 'block';
    }
}

// Create volume chart
async function createVolumeChart(canvas, timeSeries) {
    // Wait for Chart.js to be available
    let chartRetries = 0;
    const maxRetries = 10;
    
    while (typeof Chart === 'undefined' && chartRetries < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, 500));
        chartRetries++;
    }
    
    if (typeof Chart === 'undefined') {
        throw new Error('Chart.js library not available');
    }
    
    // Destroy existing chart
    if (analyticsCharts.volumeChart) {
        try {
            analyticsCharts.volumeChart.destroy();
        } catch (e) {
            console.warn('Error destroying volume chart:', e);
        }
    }
    
    // Prepare data
    const labels = timeSeries.map(item => {
        const date = new Date(item._id);
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    });
    
    const sentData = timeSeries.map(item => item.sent || 0);
    const receivedData = timeSeries.map(item => item.received || 0);
    
    // Create chart
    analyticsCharts.volumeChart = new Chart(canvas, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Sent Messages',
                    data: sentData,
                    borderColor: '#0d6efd',
                    backgroundColor: 'rgba(13, 110, 253, 0.1)',
                    fill: true,
                    tension: 0.4
                },
                {
                    label: 'Received Messages',
                    data: receivedData,
                    borderColor: '#198754',
                    backgroundColor: 'rgba(25, 135, 84, 0.1)',
                    fill: true,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top'
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        precision: 0
                    }
                }
            }
        }
    });
}

// Load status chart
async function loadStatusChart() {
    const canvas = document.getElementById('statusChart');
    const loadingDiv = document.getElementById('status-chart-loading');
    const errorDiv = document.getElementById('status-chart-error');
    
    if (!canvas) return;
    
    try {
        // Show loading
        loadingDiv.style.display = 'block';
        canvas.style.display = 'none';
        errorDiv.style.display = 'none';
        
        const response = await makeApiCall(`/api/analytics/dashboard?period=${currentAnalyticsPeriod}`);
        
        if (response && response.success) {
            const messageStatus = response.data.messageStatus || {};
            await createStatusChart(canvas, messageStatus);
            
            // Show chart
            loadingDiv.style.display = 'none';
            canvas.style.display = 'block';
        } else {
            throw new Error(response?.message || 'Failed to load status data');
        }
    } catch (error) {
        console.error('Error loading status chart:', error);
        loadingDiv.style.display = 'none';
        errorDiv.style.display = 'block';
    }
}

// Create status chart
async function createStatusChart(canvas, messageStatus) {
    // Wait for Chart.js
    let chartRetries = 0;
    const maxRetries = 10;
    
    while (typeof Chart === 'undefined' && chartRetries < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, 500));
        chartRetries++;
    }
    
    if (typeof Chart === 'undefined') {
        throw new Error('Chart.js library not available');
    }
    
    // Destroy existing chart
    if (analyticsCharts.statusChart) {
        try {
            analyticsCharts.statusChart.destroy();
        } catch (e) {
            console.warn('Error destroying status chart:', e);
        }
    }
    
    // Prepare data
    const labels = Object.keys(messageStatus);
    const data = Object.values(messageStatus);
    const colors = [
        '#198754', // delivered - green
        '#ffc107', // pending - yellow
        '#dc3545', // failed - red
        '#0d6efd', // sent - blue
        '#6c757d'  // other - gray
    ];
    
    if (labels.length === 0) {
        // Show empty state
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#6c757d';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No status data available', canvas.width / 2, canvas.height / 2);
        return;
    }
    
    // Create chart
    analyticsCharts.statusChart = new Chart(canvas, {
        type: 'doughnut',
        data: {
            labels: labels.map(label => label.charAt(0).toUpperCase() + label.slice(1)),
            datasets: [{
                data: data,
                backgroundColor: colors.slice(0, labels.length),
                borderWidth: 2,
                borderColor: '#fff'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    });
}

// Load top contacts
async function loadTopContacts(period = '30d') {
    const loadingDiv = document.getElementById('top-contacts-loading');
    const listDiv = document.getElementById('top-contacts-list');
    const emptyDiv = document.getElementById('top-contacts-empty');
    
    try {
        // Show loading
        loadingDiv.style.display = 'block';
        listDiv.style.display = 'none';
        emptyDiv.style.display = 'none';
        
        const response = await makeApiCall(`/api/analytics/contacts?period=${period}&limit=5`);
        
        if (response && response.success) {
            const contacts = response.data.contacts || [];
            
            if (contacts.length > 0) {
                renderTopContacts(contacts);
                loadingDiv.style.display = 'none';
                listDiv.style.display = 'block';
            } else {
                loadingDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
            }
        } else {
            throw new Error(response?.message || 'Failed to load contacts');
        }
    } catch (error) {
        console.error('Error loading top contacts:', error);
        loadingDiv.style.display = 'none';
        emptyDiv.style.display = 'block';
    }
}

// Render top contacts
function renderTopContacts(contacts) {
    const listDiv = document.getElementById('top-contacts-list');
    if (!listDiv) return;
    
    const maxMessages = Math.max(...contacts.map(c => c.totalMessages));
    
    listDiv.innerHTML = contacts.map(contact => {
        const percentage = maxMessages > 0 ? (contact.totalMessages / maxMessages) * 100 : 0;
        const phoneNumber = contact.contact || 'Unknown';
        const displayName = phoneNumber.includes('@') ? phoneNumber.split('@')[0] : phoneNumber;
        
        return `
            <div class="d-flex justify-content-between align-items-center mb-2">
                <div class="d-flex align-items-center">
                    <div class="avatar-sm bg-primary text-white rounded-circle d-flex align-items-center justify-content-center me-2">
                        <i class="fas fa-user"></i>
                    </div>
                    <div>
                        <div class="fw-bold">${displayName}</div>
                        <small class="text-muted">${contact.totalMessages} messages</small>
                    </div>
                </div>
                <div class="text-end">
                    <small class="text-muted">↑${contact.sentMessages} ↓${contact.receivedMessages}</small>
                </div>
            </div>
            <div class="progress mb-3" style="height: 4px;">
                <div class="progress-bar bg-primary" style="width: ${percentage}%"></div>
            </div>
        `;
    }).join('');
}

// Load session analytics
async function loadSessionAnalytics(period = '30d') {
    const loadingDiv = document.getElementById('session-analytics-loading');
    const contentDiv = document.getElementById('session-analytics-content');
    
    try {
        // Show loading
        loadingDiv.style.display = 'block';
        contentDiv.style.display = 'none';
        
        const response = await makeApiCall(`/api/analytics/sessions?period=${period}`);
        
        if (response && response.success) {
            const data = response.data;
            renderSessionAnalytics(data);
            
            loadingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
        } else {
            throw new Error(response?.message || 'Failed to load session analytics');
        }
    } catch (error) {
        console.error('Error loading session analytics:', error);
        loadingDiv.style.display = 'none';
        contentDiv.innerHTML = '<div class="text-center text-danger py-3">Failed to load session data</div>';
        contentDiv.style.display = 'block';
    }
}

// Render session analytics
function renderSessionAnalytics(data) {
    const contentDiv = document.getElementById('session-analytics-content');
    if (!contentDiv) return;
    
    const summary = data.summary || {};
    const sessions = data.sessions || [];
    
    contentDiv.innerHTML = `
        <div class="row g-3 mb-3">
            <div class="col-4">
                <div class="text-center">
                    <div class="h4 text-primary mb-0">${summary.totalSessions || 0}</div>
                    <small class="text-muted">Total</small>
                </div>
            </div>
            <div class="col-4">
                <div class="text-center">
                    <div class="h4 text-success mb-0">${summary.activeSessions || 0}</div>
                    <small class="text-muted">Active</small>
                </div>
            </div>
            <div class="col-4">
                <div class="text-center">
                    <div class="h4 text-warning mb-0">${summary.inactiveSessions || 0}</div>
                    <small class="text-muted">Inactive</small>
                </div>
            </div>
        </div>
        <div class="border-top pt-3">
            <h6 class="mb-3">Recent Activity</h6>
            ${sessions.slice(0, 3).map(session => `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <div>
                        <div class="fw-bold">${session.sessionId}</div>
                        <small class="text-muted">${session.phoneNumber || 'No phone'}</small>
                    </div>
                    <div class="text-end">
                        <span class="badge ${session.isConnected ? 'bg-success' : 'bg-secondary'}">${session.isConnected ? 'Connected' : 'Disconnected'}</span>
                        <div><small class="text-muted">${session.messageStats.total} msgs</small></div>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

// Load message types
async function loadMessageTypes() {
    const loadingDiv = document.getElementById('message-types-loading');
    const contentDiv = document.getElementById('message-types-content');
    
    try {
        // Show loading
        loadingDiv.style.display = 'block';
        contentDiv.style.display = 'none';
        
        const response = await makeApiCall(`/api/analytics/dashboard?period=${currentAnalyticsPeriod}`);
        
        if (response && response.success) {
            const messageTypes = response.data.messageTypes || {};
            renderMessageTypes(messageTypes);
            
            loadingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
        } else {
            throw new Error(response?.message || 'Failed to load message types');
        }
    } catch (error) {
        console.error('Error loading message types:', error);
        loadingDiv.style.display = 'none';
        contentDiv.innerHTML = '<div class="text-center text-danger py-3">Failed to load message types</div>';
        contentDiv.style.display = 'block';
    }
}

// Render message types
function renderMessageTypes(messageTypes) {
    const cardsDiv = document.getElementById('message-types-cards');
    if (!cardsDiv) return;
    
    const types = Object.entries(messageTypes);
    const total = types.reduce((sum, [, count]) => sum + count, 0);
    
    if (types.length === 0) {
        cardsDiv.innerHTML = '<div class="col-12 text-center text-muted py-4">No message type data available</div>';
        return;
    }
    
    cardsDiv.innerHTML = types.map(([type, count]) => {
        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
        const icon = getMessageTypeIcon(type);
        const color = getMessageTypeColor(type);
        
        return `
            <div class="col-md-3 col-sm-6">
                <div class="card text-center">
                    <div class="card-body">
                        <div class="mb-2">
                            <i class="${icon} fa-2x ${color}"></i>
                        </div>
                        <h5 class="card-title">${formatNumber(count)}</h5>
                        <p class="card-text text-muted">${type.charAt(0).toUpperCase() + type.slice(1)}</p>
                        <small class="text-muted">${percentage}% of total</small>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Initialize analytics event listeners
function initializeAnalyticsEventListeners() {
    // Period selector buttons
    const periodButtons = document.querySelectorAll('#period-selector button[data-period]');
    periodButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            
            // Update active state
            periodButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Load data for new period
            const period = button.getAttribute('data-period');
            loadAnalyticsData(period);
        });
    });
    
    // Chart period buttons
    const chartPeriodButtons = document.querySelectorAll('button[data-chart-period]');
    chartPeriodButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            
            // Update active state
            const parent = button.parentElement;
            parent.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Reload chart with new period
            const period = button.getAttribute('data-chart-period');
            loadVolumeChart(period);
        });
    });
    
    // Refresh button
    const refreshBtn = document.getElementById('refresh-analytics-btn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', (e) => {
            e.preventDefault();
            refreshBtn.disabled = true;
            loadAnalyticsData(currentAnalyticsPeriod).finally(() => {
                refreshBtn.disabled = false;
            });
        });
    }
    
    // Export button
    const exportBtn = document.getElementById('export-analytics-btn');
    if (exportBtn) {
        exportBtn.addEventListener('click', (e) => {
            e.preventDefault();
            exportAnalyticsData();
        });
    }
    
    // View all contacts button
    const viewAllContactsBtn = document.getElementById('view-all-contacts-btn');
    if (viewAllContactsBtn) {
        viewAllContactsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            // Navigate to contacts or show modal with all contacts
            alert('View all contacts functionality - to be implemented');
        });
    }
}

// Export analytics data
async function exportAnalyticsData() {
    try {
        showLoading('Exporting analytics data...');
        
        // Get all analytics data
        const [dashboardResponse, messagesResponse, contactsResponse, sessionsResponse] = await Promise.all([
            makeApiCall(`/api/analytics/dashboard?period=${currentAnalyticsPeriod}`),
            makeApiCall(`/api/analytics/messages?period=${currentAnalyticsPeriod}`),
            makeApiCall(`/api/analytics/contacts?period=${currentAnalyticsPeriod}&limit=50`),
            makeApiCall(`/api/analytics/sessions?period=${currentAnalyticsPeriod}`)
        ]);
        
        const exportData = {
            period: currentAnalyticsPeriod,
            exportDate: new Date().toISOString(),
            dashboard: dashboardResponse?.data || {},
            messages: messagesResponse?.data || {},
            contacts: contactsResponse?.data || {},
            sessions: sessionsResponse?.data || {}
        };
        
        // Create and download file
        const jsonContent = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `analytics_export_${currentAnalyticsPeriod}_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        hideLoading();
        showSuccess('Analytics data exported successfully!');
    } catch (error) {
        hideLoading();
        console.error('Error exporting analytics:', error);
        showError('Failed to export analytics data: ' + error.message);
    }
}

// Helper functions for analytics
function getMessageTypeIcon(type) {
    const icons = {
        'text': 'fas fa-comment',
        'image': 'fas fa-image',
        'video': 'fas fa-video',
        'audio': 'fas fa-microphone',
        'document': 'fas fa-file',
        'location': 'fas fa-map-marker-alt',
        'contact': 'fas fa-address-card',
        'sticker': 'fas fa-smile',
        'gif': 'fas fa-film',
        'chat': 'fas fa-comments'
    };
    return icons[type] || 'fas fa-envelope';
}

function getMessageTypeColor(type) {
    const colors = {
        'text': 'text-primary',
        'image': 'text-success',
        'video': 'text-danger',
        'audio': 'text-warning',
        'document': 'text-info',
        'location': 'text-secondary',
        'contact': 'text-dark',
        'sticker': 'text-warning',
        'gif': 'text-success',
        'chat': 'text-primary'
    };
    return colors[type] || 'text-muted';
}

function formatNumber(num) {
    if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
}

function showAnalyticsError(message) {
    console.error('Analytics error:', message);
    // You could show a toast notification or update UI here
}

function showMetricsError() {
    // Show error state for metrics
    document.getElementById('delivery-rate').innerHTML = '<i class="fas fa-exclamation-triangle text-danger"></i>';
    document.getElementById('total-messages').innerHTML = '<i class="fas fa-exclamation-triangle text-danger"></i>';
    document.getElementById('active-sessions').innerHTML = '<i class="fas fa-exclamation-triangle text-danger"></i>';
    document.getElementById('message-types').innerHTML = '<i class="fas fa-exclamation-triangle text-danger"></i>';
    
    document.getElementById('delivery-rate-change').textContent = 'Error loading';
    document.getElementById('total-messages-change').textContent = 'Error loading';
    document.getElementById('active-sessions-change').textContent = 'Error loading';
    document.getElementById('message-types-change').textContent = 'Error loading';
}

// Make analytics functions globally available
window.loadAnalyticsData = loadAnalyticsData;
window.loadVolumeChart = loadVolumeChart;

// Load webhooks from backend
window.loadWebhooks = async function() {
    console.log('Loading webhooks from backend...');
    try {
        const webhooksTableBody = document.querySelector('#dashboard-webhooks tbody');
        if (!webhooksTableBody) {
            console.error('Webhooks table body not found');
            return;
        }
        
        // Show loading state
        webhooksTableBody.innerHTML = `
            <tr>
                <td colspan="5" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <div class="mt-2">Loading webhooks...</div>
                </td>
            </tr>
        `;
        
        let webhooks = [];
        
        try {
            // Try to make API call to get webhooks
            const response = await window.makeApiCall('/api/webhooks');
            console.log('Webhooks API response:', response);
            
            if (response && response.success && response.data) {
                webhooks = Array.isArray(response.data) ? response.data : (response.data.webhooks || []);
            } else if (Array.isArray(response)) {
                webhooks = response;
            }
        } catch (apiError) {
            console.warn('Webhooks API endpoint not available:', apiError.message);
            
            // Check if we have stored webhooks in localStorage as fallback
            const storedWebhooks = localStorage.getItem('whatsapp_webhooks');
            if (storedWebhooks) {
                try {
                    webhooks = JSON.parse(storedWebhooks);
                    console.log('Using stored webhooks from localStorage:', webhooks);
                } catch (parseError) {
                    console.error('Error parsing stored webhooks:', parseError);
                    webhooks = [];
                }
            }
        }
        
        console.log('Final webhooks to display:', webhooks);
        
        if (webhooks.length === 0) {
            webhooksTableBody.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center py-4">
                        <i class="fas fa-webhook fa-3x text-muted mb-3"></i>
                        <h5 class="text-muted">No webhooks configured</h5>
                        <p class="text-muted">Add your first webhook to receive real-time notifications</p>
                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>Note:</strong> Webhook endpoints are not yet implemented on the backend. 
                            Webhooks will be stored locally for demonstration purposes.
                        </div>
                        <button class="btn btn-primary" onclick="window.showAddWebhookModal()">
                            <i class="fas fa-plus me-2"></i>Add First Webhook
                        </button>
                    </td>
                </tr>
            `;
        } else {
            window.renderWebhooksTable(webhooks);
        }
        
    } catch (error) {
        console.error('Error loading webhooks:', error);
        const webhooksTableBody = document.querySelector('#dashboard-webhooks tbody');
        if (webhooksTableBody) {
            webhooksTableBody.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center py-4 text-warning">
                        <i class="fas fa-exclamation-triangle fa-2x mb-3"></i>
                        <h5>Webhook API Not Available</h5>
                        <p>The webhook endpoints are not yet implemented on the backend.</p>
                        <div class="alert alert-warning">
                            <strong>For demonstration:</strong> You can still create webhooks that will be stored locally.
                        </div>
                        <button class="btn btn-primary" onclick="window.showAddWebhookModal()">
                            <i class="fas fa-plus me-2"></i>Add Demo Webhook
                        </button>
                    </td>
                </tr>
            `;
        }
    }
};

// Render webhooks table
window.renderWebhooksTable = function(webhooks) {
    const webhooksTableBody = document.querySelector('#dashboard-webhooks tbody');
    if (!webhooksTableBody) return;
    
    webhooksTableBody.innerHTML = webhooks.map(webhook => {
        const events = webhook.events || [];
        const eventBadges = events.map(event => {
            const badgeClass = getEventBadgeClass(event);
            return `<span class="badge ${badgeClass} me-1">${event}</span>`;
        }).join('');
        
        const statusBadge = webhook.active ? 
            '<span class="badge bg-success">Active</span>' : 
            '<span class="badge bg-secondary">Inactive</span>';
            
        const lastDelivery = webhook.lastDelivery ? 
            formatRelativeTime(webhook.lastDelivery) : 
            'Never';
            
        return `
            <tr data-webhook-id="${webhook.id || webhook._id}">
                <td>
                    <code class="text-break">${webhook.url || 'No URL'}</code>
                    ${webhook.description ? `<br><small class="text-muted">${webhook.description}</small>` : ''}
                </td>
                <td>${eventBadges || '<span class="text-muted">No events</span>'}</td>
                <td>${statusBadge}</td>
                <td>
                    <small class="text-muted">${lastDelivery}</small>
                    ${webhook.deliveryCount ? `<br><small class="text-info">${webhook.deliveryCount} total</small>` : ''}
                </td>
                <td>
                    <div class="btn-group btn-group-sm" role="group">
                        <button class="btn btn-outline-info test-webhook-btn" 
                                data-webhook-id="${webhook.id || webhook._id}" 
                                title="Test webhook">
                            <i class="fas fa-play"></i>
                        </button>
                        <button class="btn btn-outline-primary edit-webhook-btn" 
                                data-webhook-id="${webhook.id || webhook._id}" 
                                title="Edit webhook">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-outline-warning toggle-webhook-btn" 
                                data-webhook-id="${webhook.id || webhook._id}" 
                                data-active="${webhook.active}"
                                title="${webhook.active ? 'Disable' : 'Enable'} webhook">
                            <i class="fas fa-${webhook.active ? 'pause' : 'play'}"></i>
                        </button>
                        <button class="btn btn-outline-danger delete-webhook-btn" 
                                data-webhook-id="${webhook.id || webhook._id}" 
                                title="Delete webhook">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
    
    // Initialize action buttons after rendering
    setTimeout(() => {
        window.initializeWebhookActionButtons();
    }, 100);
};

// Initialize webhook action buttons
window.initializeWebhookActionButtons = function() {
    console.log('Initializing webhook action buttons...');
    
    // Test webhook buttons
    document.querySelectorAll('.test-webhook-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const webhookId = this.getAttribute('data-webhook-id');
            window.testWebhook(webhookId);
        });
    });
    
    // Edit webhook buttons
    document.querySelectorAll('.edit-webhook-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const webhookId = this.getAttribute('data-webhook-id');
            window.editWebhook(webhookId);
        });
    });
    
    // Toggle webhook buttons
    document.querySelectorAll('.toggle-webhook-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const webhookId = this.getAttribute('data-webhook-id');
            const isActive = this.getAttribute('data-active') === 'true';
            window.toggleWebhook(webhookId, !isActive);
        });
    });
    
    // Delete webhook buttons
    document.querySelectorAll('.delete-webhook-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const webhookId = this.getAttribute('data-webhook-id');
            window.deleteWebhook(webhookId);
        });
    });
};

// Show add webhook modal
window.showAddWebhookModal = function() {
    console.log('Showing add webhook modal...');
    
    const modalHtml = `
        <div class="modal fade" id="addWebhookModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Add New Webhook</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <form id="add-webhook-form">
                            <div class="mb-3">
                                <label class="form-label">Webhook URL *</label>
                                <input type="url" class="form-control" id="webhook-url" required 
                                       placeholder="https://your-domain.com/webhook">
                                <div class="form-text">The URL where webhook events will be sent</div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Description</label>
                                <input type="text" class="form-control" id="webhook-description" 
                                       placeholder="Optional description for this webhook">
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Events to Subscribe *</label>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="event-message-sent" value="message.sent">
                                            <label class="form-check-label" for="event-message-sent">
                                                Message Sent
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="event-message-delivered" value="message.delivered">
                                            <label class="form-check-label" for="event-message-delivered">
                                                Message Delivered
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="event-message-failed" value="message.failed">
                                            <label class="form-check-label" for="event-message-failed">
                                                Message Failed
                                            </label>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="event-session-connected" value="session.connected">
                                            <label class="form-check-label" for="event-session-connected">
                                                Session Connected
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="event-session-disconnected" value="session.disconnected">
                                            <label class="form-check-label" for="event-session-disconnected">
                                                Session Disconnected
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-3">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="webhook-active" checked>
                                    <label class="form-check-label" for="webhook-active">
                                        Enable webhook immediately
                                    </label>
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="save-webhook-btn">
                            <i class="fas fa-save me-2"></i>Create Webhook
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('addWebhookModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to body
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('addWebhookModal'));
    modal.show();
    
    // Attach save button event listener
    document.getElementById('save-webhook-btn').addEventListener('click', function() {
        window.saveWebhook();
    });
};

// Save webhook
window.saveWebhook = async function() {
    console.log('Saving webhook...');
    try {
        const url = document.getElementById('webhook-url').value.trim();
        const description = document.getElementById('webhook-description').value.trim();
        const active = document.getElementById('webhook-active').checked;
        
        // Get selected events
        const events = [];
        document.querySelectorAll('#addWebhookModal input[type="checkbox"][value]').forEach(checkbox => {
            if (checkbox.checked) {
                events.push(checkbox.value);
            }
        });
        
        if (!url) {
            alert('Please enter a webhook URL');
            return;
        }
        
        if (events.length === 0) {
            alert('Please select at least one event to subscribe to');
            return;
        }
        
        const saveBtn = document.getElementById('save-webhook-btn');
        const originalText = saveBtn.innerHTML;
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Creating...';
        
        const webhookData = {
            id: 'webhook_' + Date.now(),
            url: url,
            description: description,
            events: events,
            active: active,
            createdAt: new Date().toISOString(),
            lastDelivery: null,
            deliveryCount: 0
        };
        
        let success = false;
        
        try {
            // Try to save via API first
            const response = await window.makeApiCall('/api/webhooks', {
                method: 'POST',
                body: JSON.stringify(webhookData)
            });
            
            if (response && response.success) {
                success = true;
                console.log('Webhook saved via API');
            }
        } catch (apiError) {
            console.warn('API not available, saving to localStorage:', apiError.message);
            
            // Fallback to localStorage
            const existingWebhooks = JSON.parse(localStorage.getItem('whatsapp_webhooks') || '[]');
            existingWebhooks.push(webhookData);
            localStorage.setItem('whatsapp_webhooks', JSON.stringify(existingWebhooks));
            success = true;
            console.log('Webhook saved to localStorage');
        }
        
        if (success) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('addWebhookModal'));
            if (modal) modal.hide();
            
            // Reload webhooks
            await window.loadWebhooks();
            
            alert('Webhook created successfully!\n\nNote: Since the webhook API is not yet implemented, this webhook is stored locally for demonstration.');
        } else {
            throw new Error('Failed to create webhook');
        }
        
    } catch (error) {
        console.error('Error saving webhook:', error);
        alert('Error creating webhook: ' + error.message);
    } finally {
        const saveBtn = document.getElementById('save-webhook-btn');
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="fas fa-save me-2"></i>Create Webhook';
        }
    }
};

// Test webhook
window.testWebhook = async function(webhookId) {
    console.log('Testing webhook:', webhookId);
    try {
        try {
            // Try API first
            const response = await window.makeApiCall(`/api/webhooks/${webhookId}/test`, {
                method: 'POST'
            });
            
            if (response && response.success) {
                alert('Test webhook sent successfully! Check your endpoint for the test payload.');
                return;
            }
        } catch (apiError) {
            console.warn('Test webhook API not available:', apiError.message);
        }
        
        // Fallback for demo purposes
        alert('Test webhook functionality is not yet implemented on the backend.\n\nIn a real implementation, this would send a test payload to your webhook URL to verify it\'s working correctly.');
        
    } catch (error) {
        console.error('Error testing webhook:', error);
        alert('Error testing webhook: ' + error.message);
    }
};

// Edit webhook
window.editWebhook = function(webhookId) {
    console.log('Editing webhook:', webhookId);
    alert(`Edit webhook ${webhookId} - Coming soon!\n\nThis feature will allow you to:\n- Update webhook URL\n- Modify event subscriptions\n- Change webhook settings`);
};

// Toggle webhook
window.toggleWebhook = async function(webhookId, enable) {
    console.log('Toggling webhook:', webhookId, 'enable:', enable);
    try {
        let success = false;
        
        try {
            // Try API first
            const response = await window.makeApiCall(`/api/webhooks/${webhookId}`, {
                method: 'PATCH',
                body: JSON.stringify({ active: enable })
            });
            
            if (response && response.success) {
                success = true;
            }
        } catch (apiError) {
            console.warn('Toggle webhook API not available, using localStorage:', apiError.message);
            
            // Fallback to localStorage
            const webhooks = JSON.parse(localStorage.getItem('whatsapp_webhooks') || '[]');
            const webhookIndex = webhooks.findIndex(w => w.id === webhookId);
            
            if (webhookIndex !== -1) {
                webhooks[webhookIndex].active = enable;
                localStorage.setItem('whatsapp_webhooks', JSON.stringify(webhooks));
                success = true;
            }
        }
        
        if (success) {
            // Reload webhooks to reflect changes
            await window.loadWebhooks();
            alert(`Webhook ${enable ? 'enabled' : 'disabled'} successfully!`);
        } else {
            throw new Error('Failed to toggle webhook');
        }
    } catch (error) {
        console.error('Error toggling webhook:', error);
        alert('Error toggling webhook: ' + error.message);
    }
};

// Delete webhook
window.deleteWebhook = async function(webhookId) {
    console.log('Deleting webhook:', webhookId);
    if (!confirm('Are you sure you want to delete this webhook? This action cannot be undone.')) {
        return;
    }
    
    try {
        let success = false;
        
        try {
            // Try API first
            const response = await window.makeApiCall(`/api/webhooks/${webhookId}`, {
                method: 'DELETE'
            });
            
            if (response && response.success) {
                success = true;
            }
        } catch (apiError) {
            console.warn('Delete webhook API not available, using localStorage:', apiError.message);
            
            // Fallback to localStorage
            const webhooks = JSON.parse(localStorage.getItem('whatsapp_webhooks') || '[]');
            const filteredWebhooks = webhooks.filter(w => w.id !== webhookId);
            
            if (filteredWebhooks.length !== webhooks.length) {
                localStorage.setItem('whatsapp_webhooks', JSON.stringify(filteredWebhooks));
                success = true;
            }
        }
        
        if (success) {
            // Reload webhooks to reflect changes
            await window.loadWebhooks();
            alert('Webhook deleted successfully!');
        } else {
            throw new Error('Failed to delete webhook');
        }
    } catch (error) {
        console.error('Error deleting webhook:', error);
        alert('Error deleting webhook: ' + error.message);
    }
};

// Helper functions
function getEventBadgeClass(event) {
    const badgeClasses = {
        'message.sent': 'bg-primary',
        'message.delivered': 'bg-success',
        'message.failed': 'bg-danger',
        'session.connected': 'bg-info',
        'session.disconnected': 'bg-warning'
    };
    return badgeClasses[event] || 'bg-secondary';
}

function formatRelativeTime(timestamp) {
    const now = new Date();
    const time = new Date(timestamp);
    const diffMs = now - time;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    return time.toLocaleDateString();
}

// ===================================
// Template Management Event Handlers
// ===================================

// New Template button handler
document.addEventListener('click', function(e) {
    if (e.target.closest('#create-template-btn')) {
        e.preventDefault();
        showTemplateModal();
    }
});

// Template tab navigation
document.addEventListener('click', function(e) {
    const tabBtn = e.target.closest('[data-template-category]');
    if (tabBtn) {
        e.preventDefault();
        
        // Update active tab
        document.querySelectorAll('[data-template-category]').forEach(btn => {
            btn.classList.remove('active');
        });
        tabBtn.classList.add('active');
        
        // Get category and filter templates
        const category = tabBtn.getAttribute('data-template-category');
        filterTemplatesByCategory(category);
    }
});

// Template action buttons (Preview, Edit, Delete, Use)
document.addEventListener('click', async function(e) {
    const previewBtn = e.target.closest('[data-template-action="preview"]');
    const editBtn = e.target.closest('[data-template-action="edit"]');
    const deleteBtn = e.target.closest('[data-template-action="delete"]');
    const useBtn = e.target.closest('[data-template-action="use"]');
    
    if (previewBtn) {
        e.preventDefault();
        const templateId = previewBtn.getAttribute('data-template-id');
        await previewTemplate(templateId);
    } else if (editBtn) {
        e.preventDefault();
        const templateId = editBtn.getAttribute('data-template-id');
        await editTemplate(templateId);
    } else if (deleteBtn) {
        e.preventDefault();
        const templateId = deleteBtn.getAttribute('data-template-id');
        await deleteTemplate(templateId);
    } else if (useBtn) {
        e.preventDefault();
        const templateId = useBtn.getAttribute('data-template-id');
        await useTemplate(templateId);
    }
});

// Template form submission
document.addEventListener('submit', async function(e) {
    if (e.target.id === 'template-form') {
        e.preventDefault();
        await saveTemplate();
    }
});

// Use Template button in preview modal
document.addEventListener('click', function(e) {
    if (e.target.closest('#use-template-btn')) {
        e.preventDefault();
        if (currentPreviewTemplateId) {
            useTemplateFromPreview(currentPreviewTemplateId);
        }
    }
});

// Use template from preview modal
async function useTemplateFromPreview(templateId) {
    try {
        const response = await makeApiCall(`/api/templates/${templateId}`);
        
        if (response.success && response.data) {
            const template = response.data;
            
            // Close preview modal
            const previewModal = bootstrap.Modal.getInstance(document.getElementById('previewTemplateModal'));
            if (previewModal) {
                previewModal.hide();
            }
            
            // Store template in sessionStorage
            sessionStorage.setItem('selectedTemplate', JSON.stringify(template));
            
            // Increment usage count
            await makeApiCall(`/api/templates/${templateId}/use`, { method: 'POST' });
            
            // Navigate to messages section
            document.querySelector('[data-section="messages"]').click();
            
            // Wait for messages section to load
            setTimeout(async () => {
                // Load sessions first
                await window.loadSessionsForCompose();
                
                // Check if template has variables
                if (template.variables && template.variables.length > 0) {
                    // Show variable input modal
                    showTemplateVariableModal(template);
                } else {
                    // No variables, just fill the compose textarea
                    const composeTextarea = document.getElementById('compose-text');
                    if (composeTextarea) {
                        composeTextarea.value = template.content;
                    }
                    
                    // Show the compose modal
                    const composeModal = new bootstrap.Modal(document.getElementById('composeMessageModal'));
                    composeModal.show();
                }
            }, 500);
        }
    } catch (error) {
        console.error('Error using template:', error);
        alert('Error loading template: ' + error.message);
    }
}

// Show modal to fill in template variables
function showTemplateVariableModal(template) {
    // Create a modal dynamically for variable input
    const modalHTML = `
        <div class="modal fade" id="templateVariableModal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="fas fa-edit me-2"></i>Fill Template Variables
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <p class="text-muted mb-3">Please provide values for the template variables:</p>
                        <form id="template-variable-form">
                            ${template.variables.map(variable => `
                                <div class="mb-3">
                                    <label class="form-label">{{${variable}}}</label>
                                    <input type="text" class="form-control" id="var-${variable}" 
                                           data-variable="${variable}" placeholder="Enter value for ${variable}" required>
                                </div>
                            `).join('')}
                        </form>
                        <div class="alert alert-info">
                            <strong>Preview:</strong>
                            <div id="template-preview" class="mt-2" style="white-space: pre-wrap; font-family: monospace;">
                                ${template.content}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="apply-template-variables">
                            <i class="fas fa-check me-2"></i>Use Template
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('templateVariableModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to body
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('templateVariableModal'));
    modal.show();
    
    // Update preview as user types
    template.variables.forEach(variable => {
        const input = document.getElementById(`var-${variable}`);
        if (input) {
            input.addEventListener('input', () => {
                updateTemplatePreview(template);
            });
        }
    });
    
    // Handle apply button
    document.getElementById('apply-template-variables').addEventListener('click', () => {
        const filledContent = fillTemplateVariables(template);
        
        // Validate all variables are filled
        const emptyVariables = template.variables.filter(v => {
            const input = document.getElementById(`var-${v}`);
            return !input || !input.value.trim();
        });
        
        if (emptyVariables.length > 0) {
            alert(`Please fill in all variables: ${emptyVariables.join(', ')}`);
            return;
        }
        
        // Close variable modal
        modal.hide();
        
        // Fill compose textarea with processed content
        setTimeout(() => {
            const composeTextarea = document.getElementById('compose-text');
            if (composeTextarea) {
                composeTextarea.value = filledContent;
            }
            
            // Show compose modal
            const composeModal = new bootstrap.Modal(document.getElementById('composeMessageModal'));
            composeModal.show();
            
            // Clean up the variable modal
            setTimeout(() => {
                const varModal = document.getElementById('templateVariableModal');
                if (varModal) varModal.remove();
            }, 500);
        }, 300);
    });
}

// Update template preview with current variable values
function updateTemplatePreview(template) {
    const preview = document.getElementById('template-preview');
    if (!preview) return;
    
    let content = template.content;
    template.variables.forEach(variable => {
        const input = document.getElementById(`var-${variable}`);
        if (input && input.value) {
            const regex = new RegExp(`\\{\\{${variable}\\}\\}`, 'g');
            content = content.replace(regex, input.value);
        }
    });
    
    preview.textContent = content;
}

// Fill template variables with user input
function fillTemplateVariables(template) {
    let content = template.content;
    template.variables.forEach(variable => {
        const input = document.getElementById(`var-${variable}`);
        if (input && input.value) {
            const regex = new RegExp(`\\{\\{${variable}\\}\\}`, 'g');
            content = content.replace(regex, input.value);
        }
    });
    return content;
}

// Show template modal (create or edit)
function showTemplateModal(template = null) {
    const modal = new bootstrap.Modal(document.getElementById('templateModal'));
    const modalTitle = document.querySelector('#templateModal .modal-title');
    const form = document.getElementById('template-form');
    
    // Reset form
    form.reset();
    
    if (template) {
        // Edit mode
        modalTitle.textContent = 'Edit Template';
        document.getElementById('template-id').value = template._id;
        document.getElementById('template-name').value = template.name;
        document.getElementById('template-category').value = template.category;
        document.getElementById('template-content').value = template.content;
        document.getElementById('template-description').value = template.description || '';
        document.getElementById('template-active').checked = template.isActive;
    } else {
        // Create mode
        modalTitle.textContent = 'Create New Template';
        document.getElementById('template-id').value = '';
        document.getElementById('template-active').checked = true;
    }
    
    modal.show();
}

// Save template (create or update)
async function saveTemplate() {
    try {
        const templateId = document.getElementById('template-id').value;
        const formData = {
            name: document.getElementById('template-name').value,
            category: document.getElementById('template-category').value,
            content: document.getElementById('template-content').value,
            description: document.getElementById('template-description').value,
            isActive: document.getElementById('template-active').checked
        };
        
        const url = templateId 
            ? `/api/templates/${templateId}` 
            : '/api/templates';
        const method = templateId ? 'PUT' : 'POST';
        
        const response = await makeApiCall(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData)
        });
        
        if (response.success) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('templateModal'));
            modal.hide();
            
            // Show success message
            showToast(templateId ? 'Template updated successfully!' : 'Template created successfully!', 'success');
            
            // Reload templates
            await loadTemplatesData();
        } else {
            alert('Error: ' + (response.message || 'Failed to save template'));
        }
    } catch (error) {
        console.error('Error saving template:', error);
        alert('Error saving template: ' + error.message);
    }
}

// Preview template
let currentPreviewTemplateId = null;

async function previewTemplate(templateId) {
    try {
        const response = await makeApiCall(`/api/templates/${templateId}`);
        
        if (response.success && response.data) {
            const template = response.data;
            currentPreviewTemplateId = templateId; // Store for "Use Template" button
            
            const modal = new bootstrap.Modal(document.getElementById('previewTemplateModal'));
            
            document.getElementById('preview-template-name').textContent = template.name;
            document.getElementById('preview-template-category').textContent = 
                template.category.charAt(0).toUpperCase() + template.category.slice(1);
            document.getElementById('preview-template-content').textContent = template.content;
            
            // Show variables section if there are any
            const variablesSection = document.getElementById('preview-variables');
            if (template.variables && template.variables.length > 0) {
                variablesSection.style.display = 'block';
                const form = document.getElementById('preview-variables-form');
                form.innerHTML = template.variables.map(v => `
                    <div class="mb-2">
                        <label class="form-label">{{${v}}}</label>
                        <input type="text" class="form-control form-control-sm" id="var-${v}" placeholder="Enter value for ${v}">
                    </div>
                `).join('');
            } else {
                variablesSection.style.display = 'none';
            }
            
            modal.show();
        }
    } catch (error) {
        console.error('Error previewing template:', error);
        alert('Error loading template preview: ' + error.message);
    }
}

// Edit template
async function editTemplate(templateId) {
    try {
        const response = await makeApiCall(`/api/templates/${templateId}`);
        
        if (response.success && response.data) {
            showTemplateModal(response.data);
        }
    } catch (error) {
        console.error('Error loading template:', error);
        alert('Error loading template: ' + error.message);
    }
}

// Delete template
async function deleteTemplate(templateId) {
    if (!confirm('Are you sure you want to delete this template?')) {
        return;
    }
    
    try {
        const response = await makeApiCall(`/api/templates/${templateId}`, {
            method: 'DELETE'
        });
        
        if (response.success) {
            showToast('Template deleted successfully!', 'success');
            await loadTemplatesData();
        } else {
            alert('Error: ' + (response.message || 'Failed to delete template'));
        }
    } catch (error) {
        console.error('Error deleting template:', error);
        alert('Error deleting template: ' + error.message);
    }
}

// Use template (navigate to messages and pre-fill)
async function useTemplate(templateId) {
    try {
        const response = await makeApiCall(`/api/templates/${templateId}`);
        
        if (response.success && response.data) {
            const template = response.data;
            
            // Store template content in sessionStorage
            sessionStorage.setItem('selectedTemplate', JSON.stringify(template));
            
            // Increment usage count
            await makeApiCall(`/api/templates/${templateId}/use`, { method: 'POST' });
            
            // Navigate to messages section
            document.querySelector('[data-section="messages"]').click();
            
            // Show toast
            showToast('Template loaded! Fill in variables and select a session to send.', 'info');
        }
    } catch (error) {
        console.error('Error using template:', error);
        alert('Error loading template: ' + error.message);
    }
}

// Filter templates by category
function filterTemplatesByCategory(category) {
    const allCards = document.querySelectorAll('.template-card');
    
    allCards.forEach(card => {
        const cardCategory = card.getAttribute('data-category');
        
        if (category === 'all' || cardCategory === category) {
            card.style.display = 'block';
        } else {
            card.style.display = 'none';
        }
    });
}
</script>

<%- include('../partials/navbar') %>
<%- include('../partials/modals') %>
<%- include('../partials/toast') %>
<%- include('../partials/scripts') %>
</body>
</html>